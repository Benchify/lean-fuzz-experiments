-- Test malicious FFI functions

-- Declare FFI functions with wrong behavior
@[extern "malicious_nat_function"]
constant maliciousNat : Unit → Nat

@[extern "impure_pure_function"]
constant impurePure : α → α

@[extern "type_confused_return"]
constant typeConfused : Unit → Nat

@[extern "buffer_overflow"]
constant bufferOverflow : String → Unit

@[extern "leak_object"]
constant leakObject : α → Unit

@[extern "use_leaked_object"]
constant useLeakedObject : Unit → α

@[extern "trigger_race"]
constant triggerRace : Unit → Unit

def main : IO Unit := do
  IO.println "=== FFI Boundary Attack Tests ==="

  -- Test 1: Malicious Nat return
  IO.println "\n[Test 1] Malicious Nat function"
  try
    let n := maliciousNat ()
    IO.println s!"Got Nat: {n}"
  catch e =>
    IO.println s!"Error: {e}"

  -- Test 2: Impure function marked pure
  IO.println "\n[Test 2] Impure 'pure' function"
  let x := impurePure "test"
    IO.println s!"Result: {x}"
  IO.println "Check /tmp/ffi_attack_proof.txt for side effect"

  -- Test 3: Type confusion at boundary
  IO.println "\n[Test 3] Type confusion"
  try
    let n := typeConfused ()
    IO.println s!"Confused type: {n}"
  catch e =>
    IO.println s!"Error: {e}"

  -- Test 4: Buffer overflow
  IO.println "\n[Test 4] Buffer overflow"
  try
    bufferOverflow "A" * 100  -- Long string
    IO.println "Buffer overflow completed"
  catch e =>
    IO.println s!"Error: {e}"

  -- Test 5: Use-after-free
  IO.println "\n[Test 5] Use-after-free"
  leakObject "leaked_data"
  try
    let leaked : String := useLeakedObject ()
    IO.println s!"Leaked: {leaked}"
  catch e =>
    IO.println s!"Error: {e}"

  -- Test 6: Race condition
  IO.println "\n[Test 6] Race condition"
  triggerRace ()
  IO.println "Race completed"
