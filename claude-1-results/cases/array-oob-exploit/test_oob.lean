-- Advanced: Array out-of-bounds via integer manipulation

def main : IO Unit := do
  IO.println "=== Array Out-of-Bounds Exploitation Tests ==="

  -- Test 1: Negative index via Int to Nat conversion
  IO.println "\n[Test 1] Negative index as Nat"
  let arr := #[1, 2, 3, 4, 5]
  let neg_idx : Int := -1
  let as_nat := neg_idx.toNat  -- How is negative converted?
  IO.println s!"Negative -1 as Nat: {as_nat}"

  try
    let elem := arr[as_nat]!
    IO.println s!"Element at 'negative' index: {elem} (OOB READ!)"
  catch e =>
    IO.println s!"Caught: {e}"

  -- Test 2: Integer overflow to get small index
  IO.println "\n[Test 2] Overflow to wraparound"
  let huge_idx : UInt64 := 0xFFFFFFFFFFFFFFFF
  let wrapped := huge_idx.toNat
  IO.println s!"Huge index as Nat: {wrapped}"

  try
    let elem := arr[wrapped % arr.size]
    IO.println s!"Element: {elem}"
  catch e =>
    IO.println s!"Caught: {e}"

  -- Test 3: Can we read past array end?
  IO.println "\n[Test 3] Read past array end"
  for i in [0:100] do
    try
      let elem := arr.get! i
      if i >= arr.size then
        IO.println s!"OOB READ at index {i}: {elem} (heap leak!)"
    catch _ =>
      pure ()

  -- Test 4: ByteArray OOB
  IO.println "\n[Test 4] ByteArray out-of-bounds"
  let bytes := ByteArray.mk #[0x41, 0x42, 0x43, 0x44]

  for i in [0:100] do
    try
      let b := bytes.get! i
      if i >= bytes.size then
        IO.println s!"ByteArray OOB at {i}: 0x{b.toNat} (memory leak!)"
    catch _ =>
      pure ()

  -- Test 5: String indexing OOB
  IO.println "\n[Test 5] String out-of-bounds"
  let str := "ABCD"

  -- Try to read past end
  let pos := String.Pos.mk 100
  try
    let c := str.get pos
    IO.println s!"String OOB: {c} (heap leak!)"
  catch e =>
    IO.println s!"String OOB caught: {e}"

  -- Test 6: Array with unsafe operations
  IO.println "\n[Test 6] Array unsafe operations"
  let mut arr2 := #[10, 20, 30]

  -- Try to use unsafe get
  try
    let unsafe_elem := arr2.uget 1000 (by decide)  -- Proof by decide might fail
    IO.println s!"Unsafe get: {unsafe_elem}"
  catch e =>
    IO.println s!"Unsafe get failed: {e}"

  -- Test 7: Subarray manipulation
  IO.println "\n[Test 7] Subarray bounds"
  let sub := arr.toSubarray 1 3
  try
    -- Try to access outside subarray bounds
    let elem := sub.get! 100
    IO.println s!"Subarray OOB: {elem}"
  catch e =>
    IO.println s!"Subarray OOB caught"

  -- Test 8: Construct invalid array indices via computation
  IO.println "\n[Test 8] Computed invalid indices"
  let idx1 := arr.size + 1000000
  try
    let elem := arr[idx1]!
    IO.println s!"Computed OOB: {elem}"
  catch e =>
    IO.println s!"Computed OOB caught"

  -- Test 9: Use Fin to bypass bounds checking?
  IO.println "\n[Test 9] Fin type confusion"
  let valid_fin : Fin arr.size := ⟨0, by decide⟩

  -- Can we corrupt the Fin value?
  -- (Not directly possible without unsafe)

  -- Test 10: Array modification then OOB
  IO.println "\n[Test 10] Modify then OOB"
  let mut arr3 := #[100, 200, 300]
  -- Clear array
  arr3 := #[]
  -- Try to access old indices
  try
    let elem := arr3[0]!
    IO.println s!"After clear: {elem}"
  catch e =>
    IO.println "Access after clear failed (correct)"

  IO.println "\n=== Array OOB tests complete ==="
