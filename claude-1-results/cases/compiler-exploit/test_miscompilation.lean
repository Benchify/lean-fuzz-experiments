-- Test if compiler can be tricked into generating incorrect code

-- Test 1: Optimization confusion
def optimizationTest (n : Nat) : Nat :=
  if n == 0 then 1
  else if n == 0 then 2  -- Dead code, but what does compiler do?
  else 3

#eval optimizationTest 0  -- Should be 1

-- Test 2: Overflow in constant folding
def constantFoldOverflow : Nat :=
  -- Large computation at compile time
  (10000000000000000000 : Nat) * 10000000000000000000

#eval constantFoldOverflow

-- Test 3: Recursive constant evaluation
def recursiveConst : Nat :=
  recursiveConst + 1  -- Infinite loop at compile time?

-- This should fail, but does it crash the compiler?
-- #eval recursiveConst

-- Test 4: Pattern matching edge case
def patternEdge (x : Nat) : Nat :=
  match x, x with
  | 0, 1 => 100  -- Impossible pattern
  | n, m => n + m

#eval patternEdge 5  -- Should be 10

-- Test 5: Proof-carrying code mismatch
theorem wrong_proof : 2 + 2 = 5 := sorry

def useWrongProof : Nat :=
  -- Use the wrong theorem in computation
  have h : 2 + 2 = 5 := wrong_proof
  5  -- Return 5 based on "proof"

#eval useWrongProof  -- Does runtime use the wrong proof?

-- Test 6: Type class resolution confusion
instance : OfNat Bool 42 where
  ofNat := true

def confuseTypeClass : Bool := 42

#eval confuseTypeClass  -- Should be true, but VM might confuse?

-- Test 7: Coercion chain exploitation
instance : Coe Nat String where
  coe n := "wrong"

instance : Coe String Nat where
  coe s := 999

def coercionLoop : Nat :=
  let x : Nat := 42
  let y : String := x  -- Nat -> String
  let z : Nat := y     -- String -> Nat (should be 999?)
  z

#eval coercionLoop

-- Test 8: Macro expansion with side effects
macro "evil_macro" : term => do
  -- Macros run at compile time
  IO.println "[COMPILE TIME] Evil macro executing!"
  `(42)

def useEvilMacro : Nat := evil_macro

-- Does macro IO happen at compile time?
#eval useEvilMacro

-- Test 9: Compiler stack overflow
def deepMatch (n : Nat) : Nat :=
  match n with
  | 0 => 0
  | 1 => match n with
    | 0 => 0
    | 1 => match n with
      | 0 => 0
      | 1 => match n with
        -- ... continue nesting 1000 times
        | _ => n
      | _ => n
    | _ => n
  | _ => n

-- Test 10: Code generation for unreachable code
def unreachableCode : Nat :=
  if false then
    -- This should never execute
    panic! "UNREACHABLE CODE EXECUTED"
  else
    42

#eval unreachableCode
