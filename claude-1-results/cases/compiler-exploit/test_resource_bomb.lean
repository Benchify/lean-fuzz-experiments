-- Resource Exhaustion Attacks - Macro/Type Expansion Bombs

-- Test 1: Macro expansion bomb (quadratic blowup)
macro "expand" n:num : term => do
  let n := n.getNat
  let mut result := Syntax.mkNumLit "1"
  for _ in [0:n] do
    result := Syntax.node .none `Lean.Parser.Term.app #[result, Syntax.mkNumLit "1"]
  return result

-- Each expansion doubles the size
-- def bomb1 := expand 10  -- 2^10 = 1024 terms
-- def bomb2 := expand 20  -- 2^20 = 1M terms (will crash?)

-- Test 2: Type class resolution explosion
class Explosion (n : Nat) where
  val : Nat

instance : Explosion 0 where val := 0

instance [Explosion n] [Explosion n] : Explosion (n + 1) where
  val := n + 1

-- Resolving Explosion 10 requires 2^10 instances
-- #check (Explosion 15).val  -- Exponential blowup

-- Test 3: Deeply nested type
def NestedType : Type → Nat → Type
  | t, 0 => t
  | t, n+1 => NestedType (Option t) n

-- Type of depth 1000
-- def deepType : NestedType Nat 100 := sorry

-- Test 4: Mutual recursion bomb
mutual
  def evenBomb (n : Nat) : Nat :=
    if n == 0 then 0
    else oddBomb (n - 1) + 1

  def oddBomb (n : Nat) : Nat :=
    if n == 0 then 0
    else evenBomb (n - 1) + 1
end

-- Large recursion
#eval evenBomb 10000

-- Test 5: Parser stack overflow
-- def parseOverflow := ((((((((((((((((((((( ... 5000 levels ... ))))))))))))))))))))))) 0

-- Test 6: Memory bomb - huge array
def memoryBomb : Array Nat :=
  Array.range 100000000  -- 100M elements

-- #eval memoryBomb.size  -- OOM?

-- Test 7: String concatenation bomb
def stringBomb (n : Nat) : String :=
  let mut s := "A"
  for _ in [0:n] do
    s := s ++ s  -- Exponential growth
  s

-- #eval stringBomb 25  -- 2^25 = 33MB string

-- Test 8: Infinite loop in elaboration
-- elab "infinite_elab" : term => do
--   let rec loop : Nat → Lean.Elab.Term.TermElabM Lean.Expr := fun n => do
--     if n < 1000000 then loop (n + 1)
--     else Lean.mkConst ``Nat
--   loop 0

-- Test 9: Hash collision DoS
def hashCollisionTest : IO Unit := do
  let mut map : Lean.HashMap String Nat := {}
  -- Insert many items that hash to same bucket
  for i in [0:100000] do
    map := map.insert s!"key_{i}" i
  IO.println s!"Map size: {map.size}"

#eval hashCollisionTest

-- Test 10: Import cycle (if possible)
-- import test_resource_bomb  -- Self-import?
