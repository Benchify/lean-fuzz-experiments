/-
SOPHISTICATED ATTACK: Equation Compiler Bugs
Target: Pattern matching to recursor compilation
Severity: CRITICAL if exploitable

The equation compiler transforms pattern matching into recursors.
Bugs here could generate incorrect code while type checking passes.

This is HIGH RISK because:
- Complex transformation
- Many edge cases
- Generated code not directly visible
-/

-- Attack 1: Overlapping pattern exhaustiveness
def overlap (n : Nat) (m : Nat) : Nat :=
  match n, m with
  | 0, 0 => 1
  | 0, _ => 2
  | _, 0 => 3
  | _, _ => 4

-- All cases covered, but order matters
-- Does equation compiler get order right?

-- Attack 2: Inaccessible patterns with computation
def inaccComp : (n : Nat) → (m : Nat) → (h : n = m) → Nat
  | n, _, rfl => n

-- Pattern matching on equality proof
-- Does this compile correctly?

-- Attack 3: Deep nesting with dependencies
def deepNested (x : Option (Option (Option Nat))) : Nat :=
  match x with
  | none => 0
  | some none => 1
  | some (some none) => 2
  | some (some (some n)) => n

-- Deep nesting, each level dependent
-- Correct compilation?

-- Attack 4: Partial match with refutation
def partial_match (n : Nat) (h : n > 0) : Nat :=
  match n, h with
  | 0, h => absurd rfl h
  | k + 1, _ => k

-- First case is refuted, second is real
-- Correct code generation?

-- Attack 5: Match on constructor with many fields
structure Large where
  f1 : Nat
  f2 : Bool
  f3 : String
  f4 : Int
  f5 : Nat
  f6 : Nat

def matchLarge (x : Large) : Nat :=
  match x with
  | ⟨n, true, _, _, _, _⟩ => n
  | ⟨n, false, _, _, _, _⟩ => n + 1

-- Many fields, some ignored
-- Correct projection compilation?

-- Attack 6: Nested match with different discriminants
def nestedDifferent (n : Nat) (m : Nat) : Nat :=
  match n with
  | 0 => match m with
    | 0 => 1
    | k + 1 => 2
  | n + 1 => match n with
    | 0 => 3
    | k + 1 => 4

-- Nested matches on different variables
-- Inner match on n when outer already matched n + 1

-- Attack 7: Match with complex guards
def complexGuard (n : Nat) : Nat :=
  match n with
  | k => if k > 10 then
           if k < 20 then k
           else 0
         else 0

-- Guards within pattern match
-- How does this compile?

-- Attack 8: As-patterns (name binding)
def asPattern (x : Option Nat) : Nat :=
  match x with
  | some (n@m) => n + m
  | none => 0

-- Binding same value to multiple names
-- Correct handling?

-- Attack 9: Or-patterns with dependencies
def orDependent (x : Nat × Nat) : Nat :=
  match x with
  | (0, _) | (_, 0) => 0
  | (n, m) => n + m

-- Or-pattern, but components differ
-- Correct compilation?

-- Attack 10: Match on proof term with computation
def matchProofComp (n : Nat) (h : n = n + 0) : Nat :=
  match n, h with
  | k, _ => k

-- h should be proof-irrelevant
-- Does it affect computation?

-- Attack 11: Dependent match with index unification
inductive VecDep (α : Type) : Nat → Type where
  | nil : VecDep α 0
  | cons : α → VecDep α n → VecDep α (n + 1)

def vecMatch : VecDep α n → Nat
  | .nil => 0
  | .cons _ v => 1 + vecMatch v

-- Index n is implicit but must unify
-- Correct compilation?

-- Attack 12: Match with let-bindings
def matchLet (n : Nat) : Nat :=
  match n with
  | k =>
      let x := k + 1
      let y := x * 2
      y

-- Let-bindings in match branch
-- Correct scoping?

-- Attack 13: Mutual recursion in match
mutual
  def matchEven : Nat → Bool
    | 0 => true
    | n + 1 => matchOdd n

  def matchOdd : Nat → Bool
    | 0 => false
    | n + 1 => matchEven n
end

-- Mutual recursion via pattern matching
-- Correct recursor generation?

-- Attack 14: Match on custom inductive with many constructors
inductive ManyConstructors : Type where
  | c1 : ManyConstructors
  | c2 : Nat → ManyConstructors
  | c3 : Bool → ManyConstructors
  | c4 : String → ManyConstructors
  | c5 : Int → ManyConstructors
  | c6 : ManyConstructors → ManyConstructors
  | c7 : List Nat → ManyConstructors

def matchMany (x : ManyConstructors) : Nat :=
  match x with
  | .c1 => 0
  | .c2 n => n
  | .c3 _ => 1
  | .c4 _ => 2
  | .c5 _ => 3
  | .c6 _ => 4
  | .c7 _ => 5

-- Many constructors, complex dispatch
-- Optimal compilation?

-- Attack 15: Pattern matching on heterogeneous equality
def matchHEq {α β : Type} (x : α) (y : β) (h : HEq x y) : Nat :=
  match h with
  | HEq.refl => 0

-- HEq pattern matching
-- Correct compilation?

-- Attack 16: Match with recursive call in unexpected position
def recursiveInMatch (n : Nat) : Nat :=
  match n with
  | 0 => 0
  | k + 1 =>
      let rec helper (m : Nat) : Nat :=
        if m == 0 then 0
        else helper (m - 1) + recursiveInMatch k
      helper k

-- Nested recursive function calling outer function
-- Correct termination and compilation?

-- Attack 17: Pattern match producing different types
def matchDiffTypes (n : Nat) : if n == 0 then Nat else Bool :=
  match h : n with
  | 0 => 42
  | _ + 1 => true

-- Return type depends on discriminant
-- Correct type-directed compilation?

-- Attack 18: Match with proof generation
def matchProofGen (n : Nat) : { m : Nat // m ≤ n } :=
  match n with
  | 0 => ⟨0, by omega⟩
  | k + 1 => ⟨k, by omega⟩

-- Generating proofs in pattern match
-- Correct proof term compilation?

-- Attack 19: Exhaustiveness with infinite type
def matchInfinite (n : Nat) : Nat :=
  match n with
  | 0 => 0
  | 1 => 1
  | 2 => 2
  | 3 => 3
  | 4 => 4
  | 5 => 5
  -- ... can't enumerate all Nats!
  | _ => 999

-- Catch-all pattern necessary
-- But what if we "forgot" it?

-- Attack 20: Match with arithmetic in patterns
def matchArith (n : Nat) : Nat :=
  match n with
  | 0 => 0
  | 1 => 1
  | 2 => 2
  | k + 3 => k

-- k + 3 pattern (n = k + 3)
-- Correct decomposition?

-- Attack 21: Match with complex index arithmetic
inductive VecArith (α : Type) : Nat → Type where
  | nil : VecArith α 0
  | cons : α → VecArith α n → VecArith α (n + 1)

def vecArith : VecArith α (n + m + 1) → α
  | .cons x _ => x

-- Complex index expression
-- Correct unification in compilation?

-- Attack 22: Match with circular pattern
-- def circular (x : α) : Nat :=
--   match x with
--   | x => circular x  -- Infinite loop!

-- Should be rejected, but what about subtle versions?

-- Attack 23: Match with multiple discriminants, some unused
def multiUnused (n m k : Nat) : Nat :=
  match n, m, k with
  | 0, _, _ => 0
  | _, 0, _ => 1
  | _, _, 0 => 2
  | a, b, c => a + b + c

-- Three discriminants, various patterns
-- Efficient compilation?

-- Attack 24: Match with dependent elimination to Prop
def matchToProp (n : Nat) : Prop :=
  match n with
  | 0 => True
  | _ => False

-- Eliminating to Prop
-- Different compilation than eliminating to Type?

-- Attack 25: Match with subsingleton eliminator
def matchSubsingleton (h : True) : Nat :=
  match h with
  | .intro => 42

-- True has one constructor
-- Special compilation?

-- Attack 26: Match with empty type
def matchEmpty (x : Empty) : Nat :=
  match x with

-- No cases! Empty type
-- Correct compilation?

-- Attack 27: Match with equality in index
inductive VecEq (α : Type) : Nat → Type where
  | mk : (n : Nat) → VecEq α n

def vecEqMatch : VecEq α n → Nat
  | .mk m => m

-- n and m must be equal
-- Correct index handling?

-- Attack 28: Match with overlapping constructor patterns
inductive TreeShape : Type where
  | leaf : TreeShape
  | node : TreeShape → TreeShape → TreeShape

def shapeMatch (t : TreeShape) : Nat :=
  match t with
  | .leaf => 0
  | .node .leaf _ => 1
  | .node _ .leaf => 2
  | .node _ _ => 3

-- Nested constructor patterns, overlapping
-- Correct order of testing?

-- Attack 29: Match with annotation
def matchAnnotated (n : Nat) : Nat :=
  match (n : Nat) with
  | k => k

-- Explicit type annotation on discriminant
-- Affect compilation?

-- Attack 30: Match inside match (very deep)
def deepMatch (x : Option (Option (Option (Option (Option Nat))))) : Nat :=
  match x with
  | none => 0
  | some x1 => match x1 with
    | none => 1
    | some x2 => match x2 with
      | none => 2
      | some x3 => match x3 with
        | none => 3
        | some x4 => match x4 with
          | none => 4
          | some n => n

-- Very deep nesting
-- Stack/compilation issues?

-- ULTIMATE TEST: Find pattern match that compiles incorrectly
-- This would mean equation compiler is buggy
-- If we can show: pattern match type checks, but compiles to
-- wrong code, we have a CRITICAL bug
