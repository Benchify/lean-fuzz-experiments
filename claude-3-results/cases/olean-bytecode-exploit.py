#!/usr/bin/env python3
"""
Attack Vector: .olean Bytecode Manipulation
Target: Binary serialization format
Severity: CRITICAL if exploitable

This script generates malformed .olean files to test:
- Format parsing robustness
- Checksum/validation
- Buffer overflows in deserialization
- Type confusion in loaded data
- Malicious code injection via .olean files
"""

import struct
import os
import random

def create_base_lean_file():
    """Create a simple Lean file to compile"""
    with open('test_base.lean', 'w') as f:
        f.write("""
def testFunction : Nat := 42

theorem testTheorem : testFunction = 42 := rfl
""")

def generate_malformed_olean_1():
    """Test 1: Invalid magic number"""
    # .olean files likely have a magic number header
    data = b'\xFF\xFF\xFF\xFF'  # Invalid magic
    data += b'\x00' * 1000  # Padding
    with open('malformed_1.olean', 'wb') as f:
        f.write(data)

def generate_malformed_olean_2():
    """Test 2: Truncated file"""
    # Create truncated files of various sizes
    for size in [0, 1, 4, 8, 16, 32, 64]:
        with open(f'malformed_truncated_{size}.olean', 'wb') as f:
            f.write(b'\x00' * size)

def generate_malformed_olean_3():
    """Test 3: Massive size field"""
    # If format has size fields, put huge values
    data = struct.pack('<Q', 0xFFFFFFFFFFFFFFFF)  # Huge size
    data += b'\x00' * 1000
    with open('malformed_huge_size.olean', 'wb') as f:
        f.write(data)

def generate_malformed_olean_4():
    """Test 4: Invalid pointers/offsets"""
    data = b'\x00' * 100
    # Insert invalid pointer values
    for i in range(0, 100, 8):
        data = data[:i] + struct.pack('<Q', 0xDEADBEEF) + data[i+8:]
    with open('malformed_pointers.olean', 'wb') as f:
        f.write(data)

def generate_malformed_olean_5():
    """Test 5: Nested structure overflow"""
    # Create deeply nested structure markers
    data = b''
    for i in range(10000):
        data += b'\x01'  # Open structure marker
    with open('malformed_nested.olean', 'wb') as f:
        f.write(data)

def generate_malformed_olean_6():
    """Test 6: Invalid UTF-8 sequences"""
    # If .olean stores strings, test invalid UTF-8
    data = b'\x00' * 100
    # Invalid UTF-8 sequences
    invalid_utf8 = [
        b'\xFF\xFF',
        b'\xC0\x80',  # Overlong encoding
        b'\xED\xA0\x80',  # Surrogate
        b'\xF4\x90\x80\x80',  # Out of range
    ]
    for seq in invalid_utf8:
        data += seq + b'\x00' * 10
    with open('malformed_utf8.olean', 'wb') as f:
        f.write(data)

def generate_malformed_olean_7():
    """Test 7: Integer overflow in counts"""
    # If format has count fields, overflow them
    data = b''
    for val in [0x7FFFFFFF, 0x80000000, 0xFFFFFFFF, 0x100000000]:
        data += struct.pack('<Q', val)
        data += b'\x00' * 100
    with open('malformed_overflow.olean', 'wb') as f:
        f.write(data)

def generate_malformed_olean_8():
    """Test 8: Duplicate entries"""
    # If format has unique IDs, create duplicates
    data = b''
    for i in range(100):
        data += struct.pack('<I', 42)  # Same ID repeated
        data += b'\x00' * 20
    with open('malformed_duplicates.olean', 'wb') as f:
        f.write(data)

def generate_malformed_olean_9():
    """Test 9: Negative lengths"""
    data = b''
    for _ in range(10):
        data += struct.pack('<q', -1)  # Negative signed length
        data += b'\x00' * 50
    with open('malformed_negative.olean', 'wb') as f:
        f.write(data)

def generate_malformed_olean_10():
    """Test 10: Random fuzzing"""
    # Pure random data
    data = bytes(random.getrandbits(8) for _ in range(10000))
    with open('malformed_random.olean', 'wb') as f:
        f.write(data)

def test_olean_loading():
    """Create test that tries to import malformed .olean files"""
    test_content = """
-- This will try to import the malformed .olean file
-- We've created it with invalid structure
import TestBase
"""
    with open('test_malformed_import.lean', 'w') as f:
        f.write(test_content)

if __name__ == '__main__':
    print("[*] Generating malformed .olean files...")

    create_base_lean_file()
    generate_malformed_olean_1()
    generate_malformed_olean_2()
    generate_malformed_olean_3()
    generate_malformed_olean_4()
    generate_malformed_olean_5()
    generate_malformed_olean_6()
    generate_malformed_olean_7()
    generate_malformed_olean_8()
    generate_malformed_olean_9()
    generate_malformed_olean_10()
    test_olean_loading()

    print("[*] Generated malformed .olean files:")
    for f in os.listdir('.'):
        if f.endswith('.olean'):
            size = os.path.getsize(f)
            print(f"  {f}: {size} bytes")

    print("\n[*] Now test these files with:")
    print("  lean test_malformed_import.lean")
    print("  This should crash or error gracefully")
