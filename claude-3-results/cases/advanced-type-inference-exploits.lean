/-
ADVANCED TYPE INFERENCE EXPLOITS
Target: Elaborator's type inference and unification
Goal: Confuse type inference to create unsound terms

Type inference bugs can lead to:
- Type confusion (value of type A treated as type B)
- Universe level inconsistencies
- Implicit argument confusion
- Coercion bugs
-/

-- Attack 1: Ambiguous implicit arguments
def ambiguous {α : Type} [Inhabited α] {β : Type} [Inhabited β] : α → β → Nat :=
  fun _ _ => 0

-- Can we confuse which inhabited instance is used?
#check ambiguous (default : Nat) (default : Bool)

-- Attack 2: Dependent type inference
def depInfer {n : Nat} (v : Fin n) : Nat := v.val

-- What if we give wrong n?
#check depInfer (⟨0, by omega⟩ : Fin 5)

-- Can we confuse the elaborator about n?

-- Attack 3: Universe inference
def univInfer.{u, v} (α : Type u) (β : Type v) : Type (max u v) := α → β

-- Can we make elaborator infer wrong levels?
#check univInfer Nat Bool  -- u=0, v=0
#check univInfer Type Nat  -- u=1, v=0

-- Attack 4: Overloaded notation
-- Lean has overloaded +, *, etc.
-- Can we create ambiguity?

class MyAdd (α : Type) where
  add : α → α → α

instance : MyAdd Nat where
  add := Nat.add

-- Now we have two + operators (Nat.add and MyAdd.add)
-- Can elaborator get confused?

-- Attack 5: Type class chain
class C1 (α : Type) where
  f1 : α → Nat

class C2 (α : Type) where
  f2 : α → Nat

class C3 (α : Type) [C1 α] [C2 α] where
  f3 : α → Nat

-- If C3 requires both C1 and C2, can we confuse instance resolution?

-- Attack 6: Implicit lambda confusion
def implicitLam := fun {α : Type} (x : α) => x

-- Type of implicitLam is: {α : Type} → α → α
-- Can we confuse the elaborator about implicit vs explicit?

#check implicitLam 42  -- Should infer α = Nat

-- Attack 7: Unification failure
-- Force elaborator into impossible unification

def unifyBad (h : Nat = Bool) : False :=
  nomatch h  -- Nat ≠ Bool, unification fails, h is empty type

-- This is sound, but can we trick elaborator?

-- Attack 8: Cyclic type aliases
-- Can we create cycle in type definitions?

-- def CyclicType := CyclicType  -- Should fail

-- Attack 9: Higher-rank polymorphism
-- Lean supports some higher-rank types
-- Can we exploit them?

def higherRank (f : {α : Type} → α → α) : Nat :=
  f 42

#check higherRank (fun {α} x => x)

-- Attack 10: Coinductive types
-- Lean doesn't have coinductive types built-in
-- But can we simulate them and break soundness?

-- structure Stream (α : Type) where
--   head : α
--   tail : Stream α

-- This is infinite, does elaborator handle it?

-- Attack 11: Phantom types
-- Types with type parameters not used in constructors

inductive Phantom (α : Type) where
  | mk : Nat → Phantom α

-- Can we exploit phantom types for type confusion?

def phantomTest : Phantom Nat := .mk 42
def phantomTest2 : Phantom Bool := .mk 42

-- These have different types but same runtime representation
-- Can we confuse elaborator?

-- example : phantomTest = phantomTest2 := rfl  -- Should fail (different types)

-- Attack 12: Existential types
structure Exists (P : α → Prop) where
  val : α
  property : P val

-- Can we extract val without proof?

def extractWithoutProof {α : Type} {P : α → Prop} (e : Exists P) : α := e.val

-- This is OK, but can we do it in unsafe way?

-- Attack 13: Subtype confusion
def SubNat := { n : Nat // n > 0 }

def makeSubNat : SubNat := ⟨1, by omega⟩

-- Can we cast Nat to SubNat unsafely?
-- def unsafeSub : Nat → SubNat := fun n => n  -- Should fail

-- Attack 14: Type casts
-- Can we use cast to confuse types?

axiom castMagic : Nat = Bool

def confuseCast : Bool := cast castMagic 42

-- If this were allowed to compute, we'd have type confusion

-- Attack 15: Tactics and elaboration
-- Can we use tactics to generate bad terms?

example : Nat := by
  -- Can we use tactics to build invalid term?
  exact 42

-- Attack 16: Nested structures with same field names
structure A where
  x : Nat

structure B where
  x : Bool

def testA : A := ⟨42⟩
def testB : B := ⟨true⟩

-- Can elaborator confuse .x projections?
#check testA.x  -- Should be Nat
#check testB.x  -- Should be Bool

-- Attack 17: Default instances
class HasDefault (α : Type) where
  default : α

instance : HasDefault Nat where default := 0
instance : HasDefault Bool where default := false

def getDefault {α : Type} [HasDefault α] : α := HasDefault.default

#check (getDefault : Nat)   -- Should be 0
#check (getDefault : Bool)  -- Should be false

-- Can we confuse which instance is selected?

-- Attack 18: Definitional vs propositional equality
-- Definitional equality is judgmental (rfl)
-- Propositional equality needs proof

def defEq1 : Nat := 2 + 2
def defEq2 : Nat := 4

example : defEq1 = defEq2 := rfl  -- Definitional

-- But what about:
def propEq1 : Nat := if true then 4 else 0
def propEq2 : Nat := 4

-- example : propEq1 = propEq2 := rfl  -- May not be definitional

-- Can we exploit the boundary?

-- Attack 19: Auto-bound implicits
def autoBound (x : α) : α := x

-- α is automatically bound as implicit
-- Can we confuse elaborator about scope?

-- Attack 20: Macro-generated types
macro "MyType" : term => `(Nat)

def macroTest : MyType := 42

-- Can macros confuse type inference?
