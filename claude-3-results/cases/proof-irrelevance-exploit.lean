/-
SOPHISTICATED ATTACK: Proof Irrelevance Violations
Target: Kernel's handling of proof irrelevance
Severity: CRITICAL if exploitable

Proof irrelevance states that all proofs of the same Prop are equal.
If we can violate this, we can potentially:
- Extract computational content from proofs
- Create two "different" proofs that the kernel treats differently
- Break Prop/Type separation

This is one of the most subtle areas of type theory.
-/

-- Attack 1: Proof irrelevance with different proof terms
def proof1 : 2 + 2 = 4 := rfl
def proof2 : 2 + 2 = 4 := Eq.refl 4
def proof3 : 2 + 2 = 4 := by rfl
def proof4 : 2 + 2 = 4 := by exact rfl

-- All should be equal by proof irrelevance
example : proof1 = proof2 := rfl  -- Should work
example : proof2 = proof3 := rfl  -- Should work
example : proof1 = proof4 := rfl  -- Should work

-- Attack 2: Can we observe the "difference" between proofs?
-- If we could, we'd violate proof irrelevance

def observeProof (h : 2 + 2 = 4) : Nat :=
  -- This should not be possible - can't extract Nat from Prop
  -- But let's try creative approaches
  0  -- Placeholder

-- Attack 3: Subsingleton elimination
-- Propositions are subsingletons (at most one inhabitant up to definitional equality)

class MySubsingleton (α : Type) : Prop where
  allEq : ∀ (a b : α), a = b

-- If we can make Nat a subsingleton, we could prove 0 = 1!
-- instance : MySubsingleton Nat where
--   allEq := fun a b => by sorry

-- Attack 4: K axiom (Uniqueness of Identity Proofs)
-- In Lean, UIP holds for all types

theorem uip {α : Type} {x y : α} (h1 h2 : x = y) : h1 = h2 := rfl

-- But what about with dependent types?
theorem uip_dep {α : Type} {P : α → Type} {x y : α}
  {h : x = y} (p1 p2 : P x) : h ▸ p1 = h ▸ p2 := by
  cases h
  rfl

-- Can we violate this somehow?

-- Attack 5: Heterogeneous equality
-- HEq is equality between elements of potentially different types

def heq_test : HEq (0 : Nat) (0 : Nat) := HEq.refl 0

-- Can we create HEq between incompatible types?
-- axiom bad_heq : HEq (0 : Nat) (true : Bool)

-- If this were accepted, we could derive False

-- Attack 6: Proof terms in recursive functions
-- Can we use proof terms to affect computation?

def weirdRecursion (n : Nat) (h : n < 100) : Nat :=
  match n with
  | 0 => 0
  | k + 1 =>
      -- Can we extract computational content from h?
      weirdRecursion k (by omega)

-- Attack 7: Decidable propositions
-- Some Props are decidable (we can compute their truth value)

def decTest : Nat :=
  if h : 5 < 10 then 42 else 0

-- This is OK (using decidability), but can we exploit it?

-- Can we make False decidable?
-- instance : Decidable False where
--   decide := false

-- If we could, we could "compute" with False

-- Attack 8: Quotient types and proof irrelevance
-- Quotients identify elements related by equivalence

def myRelation : Nat → Nat → Prop := fun n m => n % 2 = m % 2

-- Create quotient
def MyQuot := Quot myRelation

-- Quotient.mk relies on proof irrelevance
-- Can we exploit this?

axiom q1 : MyQuot := Quot.mk myRelation 0
axiom q2 : MyQuot := Quot.mk myRelation 2

-- These should be equal (0 % 2 = 2 % 2 = 0)
axiom q_equal : q1 = q2

-- But can we observe a difference?

-- Attack 9: Cast with proof terms
def castWithProof {α β : Type} (h : α = β) (x : α) : β :=
  cast h x

-- The proof h is irrelevant for computation
-- But can we make it relevant?

-- Attack 10: Prop vs Type confusion
-- Props live in Prop, Types live in Type u
-- But both are types in a sense

def PropAsType : Type := Prop  -- This is Type 1

-- Can we confuse the two?

-- Attack 11: Large elimination from Prop (revisited with subtlety)
-- We know direct large elimination is forbidden
-- But what about indirect routes?

inductive PropWithData : Prop where
  | mkData : Nat → PropWithData

-- Can't directly extract Nat:
-- def extractData : PropWithData → Nat
--   | .mkData n => n  -- Rejected

-- But what about using casts or other tricks?

-- Attack 12: Proof irrelevance in dependent types
structure DependentProof (n : Nat) where
  proof : n < 100

-- Two DependentProof values with same n should be equal
def dp1 : DependentProof 5 := ⟨by omega⟩
def dp2 : DependentProof 5 := ⟨by omega⟩

example : dp1 = dp2 := rfl  -- Should work (proof irrelevance)

-- But what if we mix it with computation?

-- Attack 13: Proof irrelevance in pattern matching
def matchOnProof (n : Nat) (h : n > 0) : Nat :=
  match n, h with
  | k + 1, _ => k  -- Proof is irrelevant here
  | 0, h => absurd rfl h

-- Can we make proof relevance sneak in?

-- Attack 14: Classical axioms and proof irrelevance
-- Classical logic gives us choice

open Classical

-- With choice, we can extract witnesses
-- But does this violate proof irrelevance?

axiom P : Nat → Prop
axiom ex : ∃ n, P n

def chooseWitness : Nat := Classical.choose ex

-- Different proofs of ∃ n, P n should give same witness
-- Can we violate this?

-- Attack 15: Proof caching in VM
-- The VM might cache proof computations
-- Can we observe this cache?

def expensiveProof (n : Nat) : n = n := by
  -- Simulate expensive proof
  exact rfl

-- If VM caches this, can we observe side effects?

-- Attack 16: Recursion in proofs
-- Can we create non-terminating proofs that affect computation?

partial def loopingProof : False := loopingProof

-- This should be rejected, but what about more subtle versions?

-- Attack 17: Proof terms and memory representation
-- In compiled code, proof terms are erased
-- Can we exploit the gap between interpreted and compiled?

def proof_term : 2 + 2 = 4 := rfl

-- In VM: proof_term exists
-- In compiled code: proof_term is erased
-- Can this difference be exploited?

-- Attack 18: Type class proofs
-- Type class instances are proof terms
-- Can we violate coherence?

instance inst1 : ToString Nat where
  toString n := toString n

-- If we had multiple instances, which is chosen?
-- Can we exploit instance selection?

-- Attack 19: Proof terms in unsafe code
-- unsafe def useProofUnsafely (h : False) : Nat :=
--   42  -- We have False but can we use it?

-- Attack 20: Reflection on proof terms
open Lean in
def reflectOnProof : MetaM Unit := do
  let proof := Expr.const `proof1 []
  -- Can we inspect the structure of proofs?
  -- Does this violate proof irrelevance?
  return ()

-- ULTIMATE TEST: Can we create two proofs that behave differently?
axiom magic_prop : Prop
axiom magic_proof_1 : magic_prop
axiom magic_proof_2 : magic_prop

-- By proof irrelevance, these must be equal:
theorem magic_equal : magic_proof_1 = magic_proof_2 := rfl

-- But in a bugged system, they might not be!
