/-
Sophisticated Attack 5: Heterogeneous Equality (HEq) Exploits
Targeting: HEq, cast, type equality proofs

HEq allows comparing values of different types. Historical bugs in other systems:
- Confusing HEq with Eq
- Cast soundness issues
- Type equality manipulation
-/

-- Test 1: Basic HEq usage
example {α β : Type} (x : α) (y : β) (h : α = β) : HEq x (h ▸ x) := HEq.rfl

-- Test 2: HEq transitivity
example {α β γ : Type} (x : α) (y : β) (z : γ)
    (h1 : HEq x y) (h2 : HEq y z) : HEq x z :=
  h1.trans h2

-- Test 3: HEq to Eq conversion (only when types are equal)
example {α : Type} (x y : α) (h : HEq x y) : x = y :=
  eq_of_heq h

-- Test 4: Can we derive HEq for different types without proof?
-- example : HEq (1 : Nat) ("hello" : String) := sorry
-- This requires axiom/sorry

-- Test 5: Cast soundness
example {α β : Type} (h : α = β) (x : α) : (cast h x : β) = cast h x := rfl

-- Test 6: Double cast
example {α β : Type} (h : α = β) (x : α) :
    cast h (cast h.symm (cast h x)) = cast h x := by
  cases h; rfl

-- Test 7: Cast with dependent types
def depCast {n m : Nat} (h : n = m) (v : Fin n) : Fin m :=
  h ▸ v

-- Test 8: HEq with proof irrelevance
example (h1 h2 : Nat = Nat) (x : Nat) : HEq (cast h1 x) (cast h2 x) := by
  cases h1; cases h2; rfl

-- Test 9: Can we prove False using HEq incorrectly?
-- axiom badHEq : HEq (0 : Nat) (true : Bool)
-- If we had this, we'd violate type safety

-- Test 10: HEq in pattern matching
def heqMatch {α β : Type} (x : α) (y : β) (h : HEq x y) : True := trivial

-- Test 11: Recursive cast
def recCast {α β : Type} (h : α = β) : List α → List β
  | [] => []
  | x :: xs => cast h x :: recCast h xs

-- Test 12: Cast in inductive type
inductive CastBox (α : Type) where
  | mk : ∀ {β : Type}, (α = β) → β → CastBox α

def unboxCast {α : Type} : CastBox α → α
  | .mk h x => cast h.symm x

-- Test 13: Type equality transitivity
example {α β γ : Type} (h1 : α = β) (h2 : β = γ) : α = γ :=
  h1.trans h2

-- Test 14: UIP (Uniqueness of Identity Proofs) - not provable without axiom
-- example {α : Type} (x : α) (h1 h2 : x = x) : h1 = h2 := rfl
-- This fails without UIP axiom

-- Test 15: HEq with universe polymorphism
example {α : Type u} {β : Type v} (x : α) (y : β)
    (h1 : Type u = Type v) (h2 : HEq α β) (h3 : HEq x y) : True :=
  trivial

-- Test 16: Cast between equivalent types
structure Wrapper (α : Type) where
  value : α

def unwrapCast {α β : Type} (h : α = β) (w : Wrapper α) : Wrapper β :=
  { value := cast h w.value }

-- Test 17: HEq reflexivity corner case
example {α : Type} (x : α) : HEq x x := HEq.rfl

-- Always true

-- Test 18: Can we break type safety with cast?
-- def typeSafetyBreak : Bool := cast sorry (42 : Nat)
-- Requires sorry for type equality proof

-- Test 19: HEq in existential
example : ∃ (α β : Type) (x : α) (y : β), HEq x y :=
  ⟨Nat, Nat, 0, 0, HEq.rfl⟩

-- Valid when types are same

-- Test 20: Nested HEq
example {α1 α2 β1 β2 : Type} (x : α1 → β1) (y : α2 → β2)
    (h1 : α1 = α2) (h2 : β1 = β2)
    (h3 : ∀ (a1 : α1) (a2 : α2), HEq a1 a2 → HEq (x a1) (y a2)) : HEq x y := sorry

-- Complex HEq reasoning

-- Test 21: Cast composition
example {α β γ : Type} (h1 : α = β) (h2 : β = γ) (x : α) :
    cast h2 (cast h1 x) = cast (h1.trans h2) x := by
  cases h1; cases h2; rfl

-- Test 22: HEq with subtype
example {P Q : Nat → Prop} (h : P = Q) (x : {n : Nat // P n}) :
    HEq x.val x.val := HEq.rfl

-- Test 23: Type equality from HEq
-- We cannot derive α = β from ∀ x y, HEq x y without more info

-- Test 24: HEq and classical reasoning
open Classical in
example (α β : Type) : (α = β) ∨ (α ≠ β) := em (α = β)

-- Decidability of type equality (classically)

-- Test 25: Cast through type family
inductive TypeFamily : Nat → Type where
  | zero : TypeFamily 0
  | succ : (n : Nat) → TypeFamily n → TypeFamily (n + 1)

def familyCast {n m : Nat} (h : n = m) : TypeFamily n → TypeFamily m :=
  cast (by rw [h])

-- Test 26: HEq in proof terms
theorem heqInProof {α β : Type} (x : α) (y : β) (h : HEq x y) : True := trivial

-- Test 27: Large HEq chain
example {t1 t2 t3 t4 t5 : Type} (x1 : t1) (x2 : t2) (x3 : t3) (x4 : t4) (x5 : t5)
    (h12 : HEq x1 x2) (h23 : HEq x2 x3) (h34 : HEq x3 x4) (h45 : HEq x4 x5) :
    HEq x1 x5 :=
  h12.trans (h23.trans (h34.trans h45))

-- Test 28: HEq symmetry
example {α β : Type} (x : α) (y : β) (h : HEq x y) : HEq y x := h.symm

-- Test 29: Cast and rfl
example {α : Type} (x : α) : cast rfl x = x := rfl

-- Test 30: Type equality is an equivalence relation
example {α : Type} : α = α := rfl
example {α β : Type} (h : α = β) : β = α := h.symm
example {α β γ : Type} (h1 : α = β) (h2 : β = γ) : α = γ := h1.trans h2

#check depCast
#check recCast
#check unboxCast
#check unwrapCast
#check familyCast
