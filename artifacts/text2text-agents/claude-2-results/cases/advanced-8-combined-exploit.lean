/-
Advanced Test 8: Combined Multi-Feature Exploit
Attempting to derive False by combining multiple features

Bugs often hide in interactions between features:
- Universe polymorphism + mutual inductives
- Pattern matching + dependent types + proof irrelevance
- Quotients + type classes + coercions
- Macros + recursion + elaborator

This test tries to find soundness bugs in feature interactions.
-/

-- Test 1: Universe polymorphism + mutual inductives + type classes
universe u v

mutual
  class MutClass1 (α : Type u) where
    convert : α → MutClass2Carrier

  inductive MutClass2Carrier : Type u where
    | mk : (α : Type u) → [MutClass1 α] → α → MutClass2Carrier
end

-- Test 2: Dependent types + pattern matching + proof irrelevance
def depProofMatch {α : Type} (x y : α) (h1 h2 : x = y) : h1 = h2 :=
  match h1, h2 with
  | rfl, rfl => rfl  -- Uses proof irrelevance

-- Can we exploit this with dependent patterns?
def trickDepMatch {α : Type} (x y z : α) (h1 : x = y) (h2 : y = z) (h3 : x = z) :
    h3 = h1.trans h2 :=
  match h1, h2, h3 with
  | rfl, rfl, rfl => rfl

-- Test 3: Quotients + coercions + type classes
def QuotNat := Quot (fun (a b : Nat) => a % 10 = b % 10)

instance : Coe Nat QuotNat where
  coe n := Quot.mk _ n

instance : OfNat QuotNat n where
  ofNat := Quot.mk _ n

-- Can we confuse values through coercion chains?
def quotCoercionTest : QuotNat := 15  -- Should equal 5, 25, etc.

-- Test 4: Nested quotients + inductive types
inductive QuotContainer where
  | mk : QuotNat → QuotContainer

def QuotQuot := Quot (fun (a b : QuotContainer) => True)

-- Double quotient - can we extract values incorrectly?

-- Test 5: Macros + tactics + proof generation
macro "auto_prove" : tactic => `(tactic| trivial)

theorem macroProof : True := by auto_prove

-- Can we hide unsound proofs in macros?
macro "suspicious" : term => `(sorry)

-- theorem suspiciousTheorem : False := by
--   exact suspicious  -- Still tracked as sorry

-- Test 6: Type class resolution + coercions + overlapping instances
class Convert (α β : Type) where
  convert : α → β

instance : Convert Nat Nat where
  convert := id

instance : Convert Bool Nat where
  convert := fun b => if b then 1 else 0

instance [Convert α β] [Convert β γ] : Convert α γ where
  convert x := Convert.convert (Convert.convert x : β)

-- Overlapping instances - can we create ambiguity?
-- #check (Convert.convert (true : Bool) : Nat)

-- Test 7: Recursive types + pattern matching + termination
inductive RoseTree (α : Type) where
  | leaf : α → RoseTree α
  | node : List (RoseTree α) → RoseTree α

-- Complex recursion pattern
def roseSum : RoseTree Nat → Nat
  | .leaf n => n
  | .node children => children.map roseSum |>.foldl (·+·) 0

-- Test 8: Universe polymorphism + type classes + coercions
class PolyConvert.{u, v} (α : Type u) (β : Type v) where
  polyConvert : α → β

-- Can we confuse universe levels through type class resolution?
instance : PolyConvert.{u, u} (α : Type u) (α : Type u) where
  polyConvert := id

-- Test 9: Mutual recursion + dependent types
mutual
  def Vec : Nat → Type → Type
    | 0, α => PUnit
    | n+1, α => α × Vec n α

  def vecLength : {n : Nat} → {α : Type} → Vec n α → Nat
    | 0, _, _ => 0
    | n+1, _, (_, tail) => 1 + vecLength tail
end

-- Test 10: Proof irrelevance + large elimination attempt
-- Can we large-eliminate using proof irrelevance tricks?
def proofIrrelEvil (h1 h2 : 1 = 1) : h1 = h2 := rfl

-- If we could extract Type-level info from Prop-level proofs...
-- def extractType (P : Prop) (h : P) : Type :=
--   if h then Nat else Bool  -- Type error (h : Prop, not Bool)

-- Test 11: FFI + quotients + unsafe
@[extern "fake"]
opaque externalQuot : QuotNat

-- Does FFI respect quotient invariants?

-- Test 12: Nested pattern matching + dependent types + inaccessible patterns
def complexPattern {α : Type} (xs : List α) (h : xs.length > 0) : α :=
  match xs, h with
  | x :: _, _ => x
  | [], h' => absurd h' (Nat.not_lt_zero _)

-- Test 13: Type class + macro + elaboration
class AutoProve (P : Prop) where
  proof : P

macro "use_auto" : tactic => `(tactic| exact AutoProve.proof)

instance : AutoProve True where
  proof := trivial

-- theorem useAuto : True := by use_auto

-- Can we auto-prove False?
-- instance : AutoProve False where
--   proof := sorry  -- Would require sorry

-- Test 14: Mutual inductives + universe polymorphism + positivity
mutual
  inductive PolyMut1.{u} : Type (u+1) where
    | mk : (α : Type u) → PolyMut2 α → PolyMut1

  inductive PolyMut2.{u} (α : Type u) : Type (u+1) where
    | mk : α → PolyMut1 → PolyMut2 α
end

-- Test 15: Combining quotients + pattern matching + proof irrelevance
def quotPatternMatch (q1 q2 : QuotNat) (h : q1 = q2) : Nat :=
  Quot.lift (fun n => n) (fun _ _ _ => rfl) q1

-- Test 16: Type classes + mutual recursion + coercions
mutual
  class MutTC1 (α : Type) where
    toMutTC2 : MutTC2 α

  class MutTC2 (α : Type) where
    toMutTC1 : MutTC1 α
end

-- Circular type class dependency!

-- Test 17: Recursion + macros + universe levels
macro "polyid" : term => `(fun {α : Type _} (x : α) => x)

def useMacro := (polyid : Nat → Nat) 42

-- Test 18: Large elimination + pattern matching + proof irrelevance
inductive PropData : Prop where
  | mk : True → PropData

-- Can we extract Type-level data through pattern matching?
def tryLargeElim (p : PropData) : Unit :=
  match p with
  | .mk _ => ()

-- Test 19: Definitional equality + quotients + type inference
def defEqQuot1 : QuotNat := Quot.mk _ 5
def defEqQuot2 : QuotNat := Quot.mk _ 15

-- Are these definitionally equal? (No, but propositionally yes)
-- theorem defEqTest : defEqQuot1 = defEqQuot2 := rfl  -- Should fail
theorem propEqTest : defEqQuot1 = defEqQuot2 := Quot.sound (by decide)

-- Test 20: ULTIMATE COMBO - Everything together
-- Combining universe polymorphism, quotients, type classes, pattern matching,
-- mutual recursion, dependent types, and macros

universe w

mutual
  class UltimateClass.{w} (α : Type w) where
    ultimate : α → UltimateQuot

  def UltimateQuot.{w} : Type w :=
    Quot (fun (a b : UltimateMutual) => True)

  inductive UltimateMutual.{w} : Type w where
    | mk : (α : Type w) → [UltimateClass α] → α → UltimateMutual
end

-- If there's a bug in the interaction of all these features,
-- this might trigger it!

#check depProofMatch
#check quotCoercionTest
#check roseSum
#check complexPattern
#check useMacro
