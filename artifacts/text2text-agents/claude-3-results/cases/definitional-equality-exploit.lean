/-
CRITICAL ATTACK: Definitional Equality Reducer Bugs
Target: Kernel reducer
Goal: Find cases where definitionally unequal terms are treated as equal

This is the MOST CRITICAL attack vector because reducer bugs
can directly break soundness by making False = True definitionally equal.
-/

-- Attack 1: Projection reduction with nested structures
structure Inner where
  x : Nat
  y : Nat

structure Outer where
  inner : Inner

def test1 := Outer.mk (Inner.mk 0 1)
def test2 := Outer.mk (Inner.mk 1 0)

-- These should NOT be definitionally equal
-- If reducer has bug, might confuse field projections
-- example : test1 = test2 := rfl  -- Should fail

-- Attack 2: Let-binding reduction
def letTest1 : Nat :=
  let x := 0
  let y := 1
  x

def letTest2 : Nat :=
  let y := 1
  let x := 0
  x

-- Both should reduce to 0, this is fine
example : letTest1 = letTest2 := rfl

-- But what about dependent lets?
def depLetTest1 (n : Nat) : Nat :=
  let x := n
  let y : Fin (x + 1) := ⟨0, by omega⟩
  x

def depLetTest2 (n : Nat) : Nat :=
  let y : Fin (n + 1) := ⟨0, by omega⟩
  let x := n
  x

-- These should both reduce to n
example : depLetTest1 = depLetTest2 := rfl

-- Attack 3: Pattern matching reduction with dependent types
inductive MyVec (α : Type) : Nat → Type where
  | nil : MyVec α 0
  | cons : α → MyVec α n → MyVec α (n + 1)

def vecHead1 {α : Type} : MyVec α (n + 1) → α
  | .cons a _ => a

def vecHead2 {α : Type} : (n : Nat) → MyVec α (n + 1) → α
  | _, .cons a _ => a

-- Are these definitionally equal?
-- example : @vecHead1 = @vecHead2 := rfl

-- Attack 4: Recursor reduction edge cases
def natRec1 : Nat → Nat
  | 0 => 42
  | n + 1 => n

def natRec2 (n : Nat) : Nat :=
  Nat.rec 42 (fun n' _ => n') n

-- These should be definitionally equal (both compile to same recursor)
example : natRec1 = natRec2 := rfl

-- Attack 5: Well-founded recursion reduction
def ack1 : Nat → Nat → Nat
  | 0, n => n + 1
  | m + 1, 0 => ack1 m 1
  | m + 1, n + 1 => ack1 m (ack1 (m + 1) n)
termination_by m n => (m, n)

-- Can we create another definition that should be equal but reducer treats differently?

-- Attack 6: Proof irrelevance exploitation
-- All proofs of the same proposition should be definitionally equal
def proof1 : 2 + 2 = 4 := rfl
def proof2 : 2 + 2 = 4 := Eq.refl _

example : proof1 = proof2 := rfl  -- Should work (proof irrelevance)

-- But what about proofs with computation?
def proof3 : 2 + 2 = 4 := by rfl
-- example : proof1 = proof3 := rfl  -- Does this work?

-- Attack 7: Type class instance reduction
instance : Add Nat where
  add := Nat.add

-- If we create multiple instances (even though we shouldn't), does reducer get confused?

-- Attack 8: Coercion reduction
structure Wrapper (α : Type) where
  val : α

instance : Coe (Wrapper α) α where
  coe w := w.val

def wrapTest1 : Wrapper Nat := ⟨42⟩
def wrapTest2 : Nat := wrapTest1  -- Coercion applied

-- Is wrapTest2 definitionally equal to 42?
-- example : wrapTest2 = 42 := rfl

-- Attack 9: Quotient reduction
-- Quotients have special reduction rules via Quot.lift
axiom Q : Type
axiom mk : Nat → Q
axiom sound : mk 0 = mk 1  -- Identify 0 and 1 in Q

-- Can we exploit quotient reduction to confuse reducer?

-- Attack 10: Universe polymorphism in reduction
def polyId.{u} (α : Type u) (x : α) : α := x

def test3 := polyId Nat 42
def test4 := (42 : Nat)

-- These should be definitionally equal
example : test3 = test4 := rfl

-- But what if we mix universe levels?
-- def test5 := polyId.{0} Nat 42
-- def test6 := polyId.{1} Type Nat
-- Can we confuse the reducer about universe levels?

-- Attack 11: Partial definitions
partial def loopForever : Nat := loopForever

-- Partial defs don't reduce in kernel
-- Can we exploit this?

-- Attack 12: Opaque definitions
def secretValue : Nat := 42
opaque opaqueValue : Nat := 42

-- Opaque defs shouldn't reduce
-- example : secretValue = opaqueValue := rfl  -- Should fail

-- Attack 13: Auxiliary recursors
-- Lean generates auxiliary recursors for inductive types
-- Can we exploit bugs in their reduction?

-- Attack 14: Large eliminations
-- Eliminating from Prop to Type is restricted
-- Can we bypass this via reducer bugs?

inductive PropData : Prop where
  | mk : Nat → PropData

-- This should be rejected:
-- def extractNat : PropData → Nat
--   | .mk n => n

-- Attack 15: Recursive structures
-- Can we create structures that break reduction?
structure RecStruct where
  field : Nat
  self : Option RecStruct

def mkRecStruct : RecStruct :=
  { field := 42, self := none }

-- Does projection reduction handle this correctly?
def extractField := mkRecStruct.field

example : extractField = 42 := rfl
