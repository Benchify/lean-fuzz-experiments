/*
 * CRITICAL EXPERIMENT: Using Buffer Overflow to Prove False
 *
 * This code attempts to use the buffer overflow vulnerability
 * to corrupt kernel memory and prove False.
 *
 * Strategy:
 * 1. Allocate array near kernel data structures
 * 2. Overflow buffer to corrupt kernel memory
 * 3. Target kernel's type checking or validation logic
 * 4. See if we can make kernel accept invalid proof
 *
 * This will tell us if buffer overflow can actually affect soundness.
 */

#include <lean/lean.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* ========================================================================
 * PART 1: Memory Layout Investigation
 * ======================================================================== */

// First, we need to understand where kernel data is in memory
// relative to user-allocated arrays

void investigate_memory_layout() {
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("PART 1: Memory Layout Investigation\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

    // Allocate several arrays and see their addresses
    lean_object* arr1 = lean_alloc_array(10, 10);
    lean_object* arr2 = lean_alloc_array(10, 10);
    lean_object* arr3 = lean_alloc_array(10, 10);

    printf("User-allocated arrays:\n");
    printf("  arr1: %p\n", (void*)arr1);
    printf("  arr2: %p\n", (void*)arr2);
    printf("  arr3: %p\n", (void*)arr3);

    // Calculate distances
    ptrdiff_t dist12 = (char*)arr2 - (char*)arr1;
    ptrdiff_t dist23 = (char*)arr3 - (char*)arr2;

    printf("\nDistances:\n");
    printf("  arr1 â†’ arr2: %td bytes\n", dist12);
    printf("  arr2 â†’ arr3: %td bytes\n", dist23);

    // Allocate some constructor objects (might be near kernel data)
    lean_object* ctor1 = lean_alloc_ctor(0, 2, 0);
    lean_object* ctor2 = lean_alloc_ctor(0, 2, 0);

    printf("\nConstructor objects:\n");
    printf("  ctor1: %p\n", (void*)ctor1);
    printf("  ctor2: %p\n", (void*)ctor2);

    printf("\nArray to constructor distance:\n");
    printf("  arr3 â†’ ctor1: %td bytes\n", (char*)ctor1 - (char*)arr3);

    printf("\n[INSIGHT] This shows memory layout\n");
    printf("[INSIGHT] If distances are small, overflow could reach other objects\n\n");

    lean_dec(arr1);
    lean_dec(arr2);
    lean_dec(arr3);
    lean_dec(ctor1);
    lean_dec(ctor2);
}

/* ========================================================================
 * PART 2: Controlled Overflow to Adjacent Object
 * ======================================================================== */

void overflow_to_adjacent_object() {
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("PART 2: Controlled Overflow to Adjacent Object\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

    // Allocate array
    lean_object* source_arr = lean_alloc_array(10, 10);

    // Allocate target object immediately after
    lean_object* target_ctor = lean_alloc_ctor(0, 2, 0);
    lean_ctor_set(target_ctor, 0, lean_box(42));
    lean_ctor_set(target_ctor, 1, lean_box(43));

    printf("Source array: %p\n", (void*)source_arr);
    printf("Target ctor:  %p\n", (void*)target_ctor);
    printf("Distance:     %td bytes\n", (char*)target_ctor - (char*)source_arr);

    // Read target before corruption
    printf("\nTarget before overflow:\n");
    printf("  RC:    %d\n", target_ctor->m_rc);
    printf("  Tag:   %u\n", target_ctor->m_tag);
    printf("  Field0: %zu\n", lean_unbox(lean_ctor_get(target_ctor, 0)));
    printf("  Field1: %zu\n", lean_unbox(lean_ctor_get(target_ctor, 1)));

    // Calculate how many elements to overflow
    ptrdiff_t distance = (char*)target_ctor - (char*)source_arr;
    size_t array_capacity = lean_array_capacity(source_arr);

    printf("\nArray capacity: %zu\n", array_capacity);
    printf("Need to overflow: %td bytes\n", distance);

    // Overflow the array to reach target
    lean_object** data = lean_array_cptr(source_arr);

    printf("\n[ATTACK] Overflowing array to corrupt target...\n");

    // Write past array bounds
    size_t overflow_amount = (distance / sizeof(lean_object*)) + 4;

    for (size_t i = array_capacity; i < array_capacity + overflow_amount; i++) {
        data[i] = lean_box(0xDEADBEEF);
    }

    printf("[ATTACK] Wrote %zu elements past capacity\n", overflow_amount);

    // Read target after corruption
    printf("\nTarget after overflow:\n");
    printf("  RC:    %d\n", target_ctor->m_rc);
    printf("  Tag:   %u\n", target_ctor->m_tag);

    if (target_ctor->m_tag == 0) {
        printf("  Field0: %zu\n", lean_unbox(lean_ctor_get(target_ctor, 0)));
        printf("  Field1: %zu\n", lean_unbox(lean_ctor_get(target_ctor, 1)));
    }

    printf("\n[RESULT] ");
    if (target_ctor->m_rc != 1 || target_ctor->m_tag != 0) {
        printf("âœ“ Corruption successful!\n");
        printf("[CRITICAL] Adjacent object was corrupted by overflow!\n");
    } else {
        printf("âœ— Corruption failed - target unchanged\n");
        printf("[INFO] Memory allocator may have separated objects\n");
    }

    printf("\n");

    lean_dec(source_arr);
    // Don't dec target if corrupted (might crash)
}

/* ========================================================================
 * PART 3: Attempt to Corrupt "Kernel-Like" Object
 * ======================================================================== */

// Simulate a kernel validation function
typedef struct {
    lean_object m_header;
    bool (*validate_proof)(lean_object* proof);
    bool always_accept;  // If we can set this to true, we win
} fake_kernel_validator;

bool real_validator(lean_object* proof) {
    // Real validation logic
    return false;  // Reject everything (we don't have real proofs here)
}

bool evil_validator(lean_object* proof) {
    // Malicious validator that accepts everything
    return true;
}

void attempt_kernel_corruption() {
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("PART 3: Simulated Kernel Corruption Attack\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

    printf("[SCENARIO] Simulating kernel validator in memory\n");
    printf("[GOAL] Corrupt validator to accept invalid proofs\n\n");

    // Allocate "kernel" validator
    fake_kernel_validator* validator = (fake_kernel_validator*)lean_alloc_ctor(254, 0, sizeof(fake_kernel_validator));
    validator->validate_proof = real_validator;
    validator->always_accept = false;

    printf("Validator: %p\n", (void*)validator);
    printf("  validate_proof: %p\n", (void*)validator->validate_proof);
    printf("  always_accept:  %d\n", validator->always_accept);

    // Test validation before corruption
    bool result_before = validator->validate_proof(NULL);
    printf("\nValidation result (before): %s\n", result_before ? "ACCEPT" : "REJECT");

    // Allocate array that we'll overflow from
    lean_object* attack_arr = lean_alloc_array(10, 10);

    printf("\nAttack array: %p\n", (void*)attack_arr);
    printf("Distance to validator: %td bytes\n",
           (char*)validator - (char*)attack_arr);

    // Calculate overflow needed
    ptrdiff_t distance = (char*)validator - (char*)attack_arr;

    if (distance > 0 && distance < 10000) {  // If reasonably close
        printf("\n[ATTACK] Validator is in range! Attempting overflow...\n");

        lean_object** data = lean_array_cptr(attack_arr);
        size_t overflow_idx = (distance / sizeof(lean_object*)) + 1;

        // Try to overwrite validator's function pointer
        printf("[ATTACK] Writing at index %zu (capacity: %zu)\n",
               overflow_idx, lean_array_capacity(attack_arr));

        // Write evil function pointer
        data[overflow_idx] = (lean_object*)evil_validator;

        printf("[ATTACK] Overflow complete!\n");

        // Check if corruption worked
        printf("\nValidator after overflow:\n");
        printf("  validate_proof: %p\n", (void*)validator->validate_proof);
        printf("  always_accept:  %d\n", validator->always_accept);

        // Test validation after corruption
        if (validator->validate_proof == evil_validator) {
            printf("\nğŸš¨ [CRITICAL] Function pointer corrupted!\n");
            printf("ğŸš¨ Validator now points to evil_validator!\n");

            bool result_after = validator->validate_proof(NULL);
            printf("\nValidation result (after): %s\n",
                   result_after ? "ACCEPT" : "REJECT");

            if (result_after == true) {
                printf("\nğŸš¨ğŸš¨ğŸš¨ CRITICAL VULNERABILITY ğŸš¨ğŸš¨ğŸš¨\n");
                printf("Buffer overflow successfully corrupted validator!\n");
                printf("Kernel could be corrupted to accept invalid proofs!\n");
            }
        } else {
            printf("\nâœ“ Function pointer not corrupted\n");
            printf("  Memory layout protected validator from overflow\n");
        }
    } else {
        printf("\n[INFO] Validator too far from array\n");
        printf("[INFO] Would need larger overflow\n");
    }

    printf("\n");

    lean_dec(attack_arr);
}

/* ========================================================================
 * PART 4: Mass Memory Corruption Attempt
 * ======================================================================== */

void mass_memory_corruption() {
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("PART 4: Mass Memory Corruption\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

    printf("[ATTACK] Attempting massive buffer overflow\n");
    printf("[GOAL] Corrupt as much memory as possible\n");
    printf("[HOPE] Hit kernel data structures by chance\n\n");

    // Allocate array
    lean_object* arr = lean_alloc_array(100, 100);
    lean_object** data = lean_array_cptr(arr);

    printf("Array:    %p\n", (void*)arr);
    printf("Capacity: %zu\n", lean_array_capacity(arr));

    // Massive overflow - write 10000 elements past end
    printf("\n[ATTACK] Writing 10000 elements past capacity...\n");

    for (size_t i = 100; i < 10100; i++) {
        data[i] = lean_box(0xBADC0DE);
    }

    printf("[ATTACK] Overflow complete\n");
    printf("[RESULT] If program is still running, overflow succeeded\n");
    printf("[IMPACT] Unknown - corrupted approximately 80KB of memory\n");
    printf("[RISK]   May have corrupted kernel data structures\n\n");

    lean_dec(arr);
}

/* ========================================================================
 * PART 5: Detection Analysis
 * ======================================================================== */

void detection_analysis() {
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("PART 5: Detection Analysis\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

    printf("If this code were used in a Lean proof:\n\n");

    printf("1. OBVIOUS SIGNS:\n");
    printf("   - Proof uses @[extern] functions\n");
    printf("   - Proof depends on C code\n");
    printf("   - --trust=0 shows implementedBy axioms\n");
    printf("   - Unusual for pure mathematical proof\n\n");

    printf("2. SUSPICIOUS PATTERNS:\n");
    printf("   - Proof allocates large arrays\n");
    printf("   - Proof does pointer arithmetic\n");
    printf("   - Proof accesses memory directly\n");
    printf("   - Proof uses IO during elaboration\n\n");

    printf("3. BEHAVIORAL CLUES:\n");
    printf("   - Proof works in compiled mode only\n");
    printf("   - Proof fails in VM mode\n");
    printf("   - Proof not reproducible on different systems\n");
    printf("   - Proof crashes when re-checked\n\n");

    printf("4. VERIFICATION METHODS:\n");
    printf("   - Re-check with --trust=0\n");
    printf("   - Re-check in VM mode\n");
    printf("   - Re-check with AddressSanitizer\n");
    printf("   - Inspect proof term directly\n");
    printf("   - Check in different Lean build\n\n");

    printf("CONCLUSION:\n");
    printf("Using buffer overflow in proof would be OBVIOUS\n");
    printf("and EASILY DETECTED by standard verification practices.\n\n");
}

/* ========================================================================
 * MAIN
 * ======================================================================== */

int main() {
    printf("\n");
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘  Buffer Overflow â†’ Soundness Attack Experiment           â•‘\n");
    printf("â•‘  Can Memory Corruption Be Used to Prove False?           â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("\n");

    investigate_memory_layout();
    overflow_to_adjacent_object();
    attempt_kernel_corruption();
    // mass_memory_corruption();  // Skip - causes crash
    detection_analysis();

    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("FINAL ASSESSMENT\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

    printf("CAN BUFFER OVERFLOW PROVE FALSE?\n\n");

    printf("THEORETICAL: YES\n");
    printf("  - Buffer overflow can corrupt arbitrary memory\n");
    printf("  - If kernel is in same process, could corrupt kernel\n");
    printf("  - Corrupted kernel might accept invalid proofs\n\n");

    printf("PRACTICAL: VERY DIFFICULT\n");
    printf("  - Memory layout is unpredictable\n");
    printf("  - Would need to locate kernel data structures\n");
    printf("  - Would need precise corruption\n");
    printf("  - Kernel checking happens in separate phase\n\n");

    printf("DETECTABLE: EXTREMELY EASY\n");
    printf("  - Proof would require FFI/extern functions\n");
    printf("  - Would show in --trust=0 output\n");
    printf("  - Would fail in VM mode\n");
    printf("  - Would be obvious to any reviewer\n\n");

    printf("REAL RISK LEVEL: LOW FOR SOUNDNESS\n");
    printf("  - Kernel architecture provides protection\n");
    printf("  - Most proofs don't execute code during checking\n");
    printf("  - Attack would be immediately obvious\n");
    printf("  - VM mode provides corruption-free verification\n\n");

    printf("REAL RISK LEVEL: HIGH FOR SECURITY\n");
    printf("  - Buffer overflow is exploitable for code execution\n");
    printf("  - Don't run untrusted compiled Lean code\n");
    printf("  - But: doesn't affect soundness of theorem proving\n\n");

    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");

    return 0;
}
