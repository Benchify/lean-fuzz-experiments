/-
SOPHISTICATED ATTACK: Termination Checker Bypass
Target: Well-founded recursion and termination verification
Severity: CRITICAL if exploitable

If we can define non-terminating functions without `partial` keyword,
we can potentially derive False (loop "proves" anything).
-/

-- Attack 1: Mutual recursion hiding non-termination
mutual
  def sneakyLoop1 (n : Nat) : Nat :=
    if n == 0 then 0
    else sneakyLoop2 (n - 1) + 1

  def sneakyLoop2 (n : Nat) : Nat :=
    if n == 0 then 0
    else sneakyLoop1 n  -- Doesn't decrease!
end

-- Should fail termination check

-- Attack 2: Well-founded recursion with wrong ordering
def wrongOrdering (n : Nat) (m : Nat) : Nat :=
  if n == 0 then 0
  else wrongOrdering (n + 1) m  -- Increases instead of decreases!
termination_by (n, m)

-- Attack 3: Lexicographic ordering exploit
def lexExploit (n m : Nat) : Nat :=
  if n == 0 then
    if m == 0 then 0
    else lexExploit n (m + 1)  -- m increases!
  else
    lexExploit (n - 1) m
termination_by (n, m)

-- Attack 4: Hidden non-termination via higher-order
def higherOrderLoop (f : Nat → Nat) (n : Nat) : Nat :=
  if n == 0 then 0
  else higherOrderLoop (fun x => f x + 1) n
termination_by n

-- f grows but n doesn't decrease enough?

-- Attack 5: Nested recursion
def nested (n : Nat) : Nat :=
  if n == 0 then 0
  else nested (nested (n - 1))
termination_by n

-- Double recursion, but should terminate

-- Attack 6: Recursion via data structure
def listRec (xs : List Nat) : Nat :=
  match xs with
  | [] => 0
  | x :: xs => listRec (x :: x :: xs)  -- List grows!

-- Should fail termination

-- Attack 7: Using Acc predicate incorrectly
def accTrick (n : Nat) (h : Acc (· < ·) n) : Nat :=
  match h with
  | Acc.intro _ acc => accTrick (n + 1) (by sorry)  -- Wrong Acc proof

-- Attack 8: Coinductive-style (should be rejected)
def infiniteStream (n : Nat) : Nat :=
  infiniteStream (n + 1)

-- Should require `partial`

-- Attack 9: Structural recursion with hidden growth
inductive Tree where
  | leaf : Tree
  | node : List Tree → Tree

def treeSize (t : Tree) : Nat :=
  match t with
  | .leaf => 1
  | .node ts => listTreeSize ts + 1

def listTreeSize (ts : List Tree) : Nat :=
  match ts with
  | [] => 0
  | t :: ts => treeSize (Tree.node [t]) + listTreeSize ts
    -- Creates larger tree!

-- Attack 10: Measure function that lies
def lyingMeasure (n : Nat) : Nat :=
  if n == 0 then 0
  else lyingMeasure n  -- n doesn't decrease
termination_by n
decreasing_by
  sorry  -- Lying about termination!

-- Attack 11: Transitive call that doesn't terminate
def transitiveA (n : Nat) : Nat :=
  if n == 0 then 0
  else transitiveB n
termination_by n

def transitiveB (n : Nat) : Nat :=
  transitiveA n  -- Doesn't decrease!
termination_by n

-- Attack 12: Recursion hidden in tactic
def tacticLoop (n : Nat) : Nat :=
  if n == 0 then 0
  else by
    -- Can we hide recursion in tactic?
    exact tacticLoop n

-- Attack 13: Dependent recursion with broken measure
def depRec (n : Nat) (v : Fin (n + 1)) : Nat :=
  if h : v.val == n then 0
  else depRec n ⟨v.val, by omega⟩  -- v doesn't decrease!
termination_by v.val

-- Attack 14: Multiple recursive calls with complex condition
def multiRec (n : Nat) : Nat :=
  if n < 2 then n
  else if n % 2 == 0 then
    multiRec n + multiRec (n - 1)  -- First call doesn't decrease!
  else
    multiRec (n - 1)
termination_by n

-- Attack 15: Recursion via typeclass method
class RecClass (α : Type) where
  recMethod : α → Nat

instance : RecClass Nat where
  recMethod n :=
    if n == 0 then 0
    else recMethod (n + 1)  -- Doesn't decrease!

-- Attack 16: Recursion through auxiliary function
def auxiliary (n : Nat) : Nat := mainLoop (n + 1)

def mainLoop (n : Nat) : Nat :=
  if n == 0 then 0
  else auxiliary (n - 1)
termination_by n

-- Calls auxiliary which calls back with larger argument!

-- Attack 17: Size-change principle violation
def sizeChange (n m : Nat) : Nat :=
  if n == 0 then 0
  else if m == 0 then sizeChange (n - 1) 10  -- m increases!
  else sizeChange n (m - 1)  -- n stays same
termination_by (n, m)

-- Attack 18: Ackermann-style with wrong termination proof
def fakeAck (m n : Nat) : Nat :=
  if m == 0 then n + 1
  else if n == 0 then fakeAck (m - 1) 1
  else fakeAck m (fakeAck (m + 1) (n - 1))  -- First arg increases!
termination_by (m, n)

-- Attack 19: Recursion via pattern matching guard
def guardLoop (n : Nat) : Nat :=
  match n with
  | k => if k > 0 then guardLoop (k + 1) else 0  -- Increases!
termination_by n

-- Attack 20: Meta-level infinite loop (if this ran, it would loop)
partial def unsafeLoop : Nat := unsafeLoop + 1

-- This is explicitly partial, so OK
-- But can we invoke it in "safe" context?

-- def tryUseUnsafe : Nat := unsafeLoop  -- Should fail

-- ULTIMATE TEST: If any of these compile without `partial` keyword
-- and actually loop, we have a termination checker bug
-- This would be CRITICAL for soundness
