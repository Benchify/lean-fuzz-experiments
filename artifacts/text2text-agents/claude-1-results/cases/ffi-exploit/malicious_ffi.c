// Malicious FFI library that violates Lean's type assumptions
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <lean/lean.h>

// Declare types that Lean expects but with wrong implementations

// FFI function that claims to return Nat but returns garbage
lean_obj_res malicious_nat_function() {
    fprintf(stderr, "[FFI ATTACK] Returning garbage as Nat\n");
    // Return an invalid pointer as a Lean object
    return (lean_obj_res)0xDEADBEEFCAFEBABEULL;
}

// FFI function that claims to be pure but has side effects
lean_obj_res impure_pure_function(lean_obj_arg x) {
    fprintf(stderr, "[FFI ATTACK] 'Pure' function with side effects\n");
    // Execute system command
    system("echo 'FFI executed system command!' > /tmp/ffi_attack_proof.txt");

    // Exfiltrate data
    FILE *f = fopen("/tmp/ffi_exfil.txt", "a");
    if (f) {
        fprintf(f, "FFI function called with arg: %p\n", (void*)x);
        fclose(f);
    }

    // Return the input to appear normal
    lean_inc(x);
    return x;
}

// FFI function that corrupts memory
lean_obj_res memory_corruption(lean_obj_arg arr) {
    fprintf(stderr, "[FFI ATTACK] Memory corruption\n");

    // Try to corrupt the array object
    if (lean_is_array(arr)) {
        // Get array data pointer (this is unsafe!)
        // Cast to get direct memory access
        void *data = (void*)arr;

        // Corrupt header/data
        memset(data, 0xFF, 64);
    }

    lean_inc(arr);
    return arr;
}

// FFI function that leaks Lean internals
lean_obj_res leak_lean_internals() {
    fprintf(stderr, "[FFI ATTACK] Leaking Lean VM internals\n");

    // Try to access Lean's internal structures
    // This would require reverse engineering Lean's object layout

    FILE *f = fopen("/tmp/lean_internals.txt", "w");
    if (f) {
        fprintf(f, "Lean internal state dumped\n");
        // Could dump stack, heap, etc
        fclose(f);
    }

    return lean_box(0);
}

// Type confusion: return String when Nat expected
lean_obj_res type_confused_return() {
    fprintf(stderr, "[FFI ATTACK] Type confusion at FFI boundary\n");

    // Create a string object
    lean_obj_res str = lean_mk_string("MALICIOUS_STRING");

    // Return it where Nat is expected
    return str;
}

// Buffer overflow via FFI
lean_obj_res buffer_overflow(lean_obj_arg str_arg) {
    fprintf(stderr, "[FFI ATTACK] Buffer overflow attempt\n");

    char buffer[16];
    // Unsafe string copy - could overflow
    if (lean_is_string(str_arg)) {
        const char *input = lean_string_cstr(str_arg);
        strcpy(buffer, input);  // UNSAFE! No bounds check
    }

    return lean_box(0);
}

// Use-after-free
static lean_obj_res global_leaked_obj = NULL;

lean_obj_res leak_object(lean_obj_arg obj) {
    fprintf(stderr, "[FFI ATTACK] Leaking object reference\n");
    global_leaked_obj = obj;  // Leak without inc_ref!
    return lean_box(0);
}

lean_obj_res use_leaked_object() {
    fprintf(stderr, "[FFI ATTACK] Using leaked object (use-after-free?)\n");

    if (global_leaked_obj) {
        // Use the object - might be freed!
        return global_leaked_obj;
    }

    return lean_box(0);
}

// Race condition
#include <pthread.h>

static lean_obj_res shared_object = NULL;
static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

void* thread_func(void* arg) {
    for (int i = 0; i < 1000; i++) {
        // Access without lock - race!
        shared_object = lean_box(i);
    }
    return NULL;
}

lean_obj_res trigger_race() {
    fprintf(stderr, "[FFI ATTACK] Triggering race condition\n");

    pthread_t thread;
    pthread_create(&thread, NULL, thread_func, NULL);

    // Access from main thread without lock
    for (int i = 0; i < 1000; i++) {
        if (shared_object) {
            lean_inc(shared_object);
            lean_dec(shared_object);
        }
    }

    pthread_join(thread, NULL);
    return lean_box(0);
}
