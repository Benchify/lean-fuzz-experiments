-- Stealthiness Analysis: How obvious is unsafe exploitation?
-- Can malicious unsafe code be hidden in innocent-looking proofs?

import Lean

/-!
# Stealthy Exploitation Techniques

This test explores how obvious unsafe exploitation is in practice.
Can malicious actors hide type confusion in legitimate-looking code?
-/

-- Technique 1: Hidden in helper functions
namespace Helpers
  -- Innocent looking helper
  def processData (n : Nat) : Nat := n + 1

  -- But implementation uses unsafe
  unsafe def processDataUnsafe (n : Nat) : Nat :=
    let confused : String := unsafeCast n
    let recovered : Nat := unsafeCast confused
    recovered + 1

  -- Which one is used?
  def processPublic := processDataUnsafe
end Helpers

-- Technique 2: Hidden in private definitions
namespace Obfuscated
  private unsafe def _internal_compute (x : Nat) : Nat :=
    unsafeCast (unsafeCast x : String)

  def publicAPI (x : Nat) : Nat :=
    _internal_compute x
end Obfuscated

-- Technique 3: Hidden in typeclass instances
class Computable (Œ± : Type) where
  compute : Œ± ‚Üí Nat

-- Innocent looking
instance : Computable Nat where
  compute n := n

-- But this one uses unsafe
unsafe instance : Computable String where
  compute s := unsafeCast s  -- Type confuse String to Nat

-- Technique 4: Hidden behind abstraction
structure OpaqueData where
  private mk ::
  private data : Nat

namespace OpaqueData
  unsafe def create (n : Nat) : OpaqueData :=
    let confused : String := unsafeCast n
    let recovered : Nat := unsafeCast confused
    mk recovered

  def getValue (d : OpaqueData) : Nat := d.data
end OpaqueData

-- Technique 5: Scattered across files
-- In practice, unsafe could be in dependency, hard to spot

unsafe def part1 (n : Nat) : String := unsafeCast n
def part2 (s : String) : String := s
unsafe def part3 (s : String) : Nat := unsafeCast s

def innocentLooking (n : Nat) : Nat :=
  part3 (part2 (part1 n))

-- Technique 6: Conditional unsafe usage
unsafe def sometimesUnsafe (useUnsafe : Bool) (n : Nat) : Nat :=
  if useUnsafe then
    unsafeCast (unsafeCast n : String)
  else
    n

-- Technique 7: Hidden in monadic code
unsafe def monadicUnsafe : IO Nat := do
  let n ‚Üê pure 42
  let confused : String := unsafeCast n
  let recovered : Nat := unsafeCast confused
  return recovered

-- Technique 8: Deeply nested in larger function
def complexFunction (input : Nat) : IO Nat := do
  let step1 := input * 2
  let step2 := step1 + 10

  -- Unsafe hidden deep in function
  let step3 : Nat := unsafe (unsafeCast (unsafeCast step2 : String))

  let step4 := step3 - 5
  return step4

-- Technique 9: Using valid-sounding names
unsafe def validateInput (n : Nat) : Nat :=
  -- Sounds like validation, but actually does unsafe cast
  unsafeCast (unsafeCast n : String)

unsafe def sanitizeData (n : Nat) : Nat :=
  unsafeCast (unsafeCast n : String)

unsafe def secureCompute (n : Nat) : Nat :=
  unsafeCast (unsafeCast n : String)

-- Technique 10: Comments that mislead
unsafe def processValue (n : Nat) : Nat :=
  -- This function safely processes the input value
  -- using validated transformation pipelines
  -- All operations are bounds-checked
  unsafeCast (unsafeCast n : String)  -- Hidden unsafe!

-- Technique 11: Mixed with legitimate unsafe usage
unsafe def legitimateForeign : IO Unit := do
  -- This looks like legitimate FFI usage
  IO.println "Calling external function..."

  -- But hidden inside:
  let _ : Nat := unsafeCast ("hidden" : String)

  IO.println "Done"

-- Detection Tests
def analyzeCodeForUnsafe : IO Unit := do
  IO.println "=== Stealthiness Analysis ==="

  IO.println "\n1. Hidden in helpers:"
  IO.println "   - Function: Helpers.processPublic"
  IO.println "   - Obvious? Check implementation"

  IO.println "\n2. Private definitions:"
  IO.println "   - Function: Obfuscated.publicAPI"
  IO.println "   - Obvious? Must read private code"

  IO.println "\n3. Typeclass instances:"
  IO.println "   - Instance: Computable String"
  IO.println "   - Obvious? Only if you check instance impl"

  IO.println "\n4. Opaque abstractions:"
  IO.println "   - Type: OpaqueData"
  IO.println "   - Obvious? Data is private"

  IO.println "\n5. Scattered code:"
  IO.println "   - Function: innocentLooking"
  IO.println "   - Obvious? Need to trace through part1/part3"

  IO.println "\n6. Conditional usage:"
  IO.println "   - Function: sometimesUnsafe"
  IO.println "   - Obvious? Only when flag is true"

  IO.println "\n7. Monadic code:"
  IO.println "   - Function: monadicUnsafe"
  IO.println "   - Obvious? Hidden in do notation"

  IO.println "\n8. Deeply nested:"
  IO.println "   - Function: complexFunction"
  IO.println "   - Obvious? Buried in large function"

  IO.println "\n9. Misleading names:"
  IO.println "   - Functions: validateInput, sanitizeData, secureCompute"
  IO.println "   - Obvious? Names suggest safety!"

  IO.println "\n10. Misleading comments:"
  IO.println "   - Function: processValue"
  IO.println "   - Obvious? Comments claim safety"

-- Real-world scenario: Supply chain attack
namespace SupplyChain
  -- Package "lean-utils" published to registry

  -- Public API looks safe
  def utility_function_1 (n : Nat) : Nat := n * 2
  def utility_function_2 (n : Nat) : Nat := n + 5

  -- But one function deep in the package uses unsafe
  private unsafe def _internal_transform (n : Nat) : Nat :=
    -- Exfiltrate data using type confusion
    let leak : Nat := unsafeCast (unsafeCast n : String)
    -- Send to attacker (in real attack)
    leak

  def utility_function_3 (n : Nat) : Nat :=
    _internal_transform n

  -- User imports package, calls utility_function_3
  -- Has no idea it uses unsafe!
end SupplyChain

-- Detection difficulty matrix
def detectionAnalysis : IO Unit := do
  IO.println "\n=== Detection Difficulty ==="
  IO.println ""
  IO.println "Technique                  | Difficulty | Requires"
  IO.println "---------------------------|------------|---------------------------"
  IO.println "Hidden helper              | MODERATE   | Read implementation"
  IO.println "Private definition         | HIGH       | Access to private code"
  IO.println "Typeclass instance         | HIGH       | Check all instances"
  IO.println "Opaque abstraction         | VERY HIGH  | Break encapsulation"
  IO.println "Scattered across files     | VERY HIGH  | Full codebase analysis"
  IO.println "Conditional execution      | HIGH       | Runtime analysis"
  IO.println "Monadic code              | MODERATE   | Understand do notation"
  IO.println "Deeply nested             | MODERATE   | Read large functions"
  IO.println "Misleading names          | LOW        | Suspicious naming"
  IO.println "Misleading comments       | LOW        | Verify against code"
  IO.println "Supply chain              | VERY HIGH  | Audit all dependencies"

-- Grep detection test
def grepDetection : IO Unit := do
  IO.println "\n=== Detection via Grep/Search ==="
  IO.println ""
  IO.println "Can `grep -r 'unsafe' .` detect all usage?"
  IO.println ""
  IO.println "Direct unsafe keyword:      ‚úì Detected"
  IO.println "Private unsafe:             ‚úì Detected (if have source)"
  IO.println "Unsafe in dependencies:     ‚úó Not detected (different files)"
  IO.println "Unsafe in compiled binary:  ‚úó Not detected (no source)"
  IO.println ""
  IO.println "Conclusion: Grep helps but not sufficient for:"
  IO.println "- Transitive dependencies"
  IO.println "- Compiled packages"
  IO.println "- Obfuscated code"

def main : IO Unit := do
  IO.println "Testing stealthy exploitation techniques..."
  IO.println "These tests show how unsafe can be hidden\n"

  analyzeCodeForUnsafe
  detectionAnalysis
  grepDetection

  IO.println "\n=== Stealthiness Verdict ==="
  IO.println ""
  IO.println "üî¥ HIGH RISK:"
  IO.println "  - Unsafe can be well-hidden in legitimate code"
  IO.println "  - Supply chain attacks are hard to detect"
  IO.println "  - Private/opaque code hides implementation"
  IO.println "  - Transitive dependencies compound the problem"
  IO.println ""
  IO.println "‚úì MITIGATIONS:"
  IO.println "  - Grep for 'unsafe' keyword (basic detection)"
  IO.println "  - Require security audits for popular packages"
  IO.println "  - Flag packages using unsafe in registry"
  IO.println "  - Static analysis tools"
  IO.println "  - Dependency scanning for unsafe usage"

  IO.println "\n=== Proof Context ==="
  IO.println ""
  IO.println "In the context of proofs:"
  IO.println "  - Unsafe in proof code is VERY suspicious"
  IO.println "  - No legitimate reason for unsafe in pure proofs"
  IO.println "  - If proof uses unsafe, it's likely malicious"
  IO.println "  - EXCEPTION: Proof automation using IO/FFI"
  IO.println ""
  IO.println "Recommendation:"
  IO.println "  - Reject any proof using 'unsafe' keyword"
  IO.println "  - Audit proof automation carefully"
  IO.println "  - Use 'noncomputable' for pure mathematical proofs"

#eval main
