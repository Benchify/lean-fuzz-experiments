-- Test: Can we leak information before the crash?
-- Extract object representations and heap layout info

unsafe def main : IO Unit := do
  IO.println "=== Information Disclosure via Type Confusion ==="

  -- Test 1: Extract pointer representation
  IO.println "\n[Test 1] Object pointer representation:"
  let str1 := "SECRET_A"
  let str2 := "SECRET_B"
  let str3 := "SECRET_C"

  let addr1 : Nat := unsafeCast str1
  let addr2 : Nat := unsafeCast str2
  let addr3 : Nat := unsafeCast str3

  IO.println s!"String 1 address: {addr1}"
  IO.println s!"String 2 address: {addr2}"
  IO.println s!"String 3 address: {addr3}"

  -- Reveal heap layout
  if addr2 > addr1 then
    IO.println s!"Distance 1→2: {addr2 - addr1} bytes"
  if addr3 > addr2 then
    IO.println s!"Distance 2→3: {addr3 - addr2} bytes"

  -- Test 2: Array representation
  IO.println "\n[Test 2] Array pointer representation:"
  let arr := #[1, 2, 3, 4, 5]
  let arr_addr : Nat := unsafeCast arr
  IO.println s!"Array address: {arr_addr}"

  -- Test 3: Function representation
  IO.println "\n[Test 3] Function pointer representation:"
  let func : Nat → Nat := fun x => x + 1
  let func_addr : Nat := unsafeCast func
  IO.println s!"Function address: {func_addr}"

  -- Test 4: Proof object representation
  IO.println "\n[Test 4] Proof object representation:"
  let proof : 1 = 1 := rfl
  let proof_addr : Nat := unsafeCast proof
  IO.println s!"Proof address: {proof_addr} (reveals proof object size)"

  -- Test 5: IO action representation
  IO.println "\n[Test 5] IO action representation:"
  let io_act : IO Nat := pure 42
  let io_addr : Nat := unsafeCast io_act
  IO.println s!"IO action address: {io_addr}"

  IO.println "\n=== Information disclosure complete (before crash) ==="
  IO.println "This reveals heap layout and object sizes"
