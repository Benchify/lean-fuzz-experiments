/-
Testing EXACTLY what debug.skipKernelTC skips
Based on AddDecl.lean analysis, skipKernelTC causes:
  addDeclWithoutChecking instead of addDeclCore

This should skip TYPE CHECKING but still do other validations
Let's test what actually gets skipped
-/

-- Test 1: Axiom with TYPE ERROR (should fail even with skipKernelTC? Let's see)
-- axiom typeError : Nat := "string"  -- This is malformed, will fail at elaboration

-- Test 2: Definition with wrong type (should fail without skip, pass with skip?)
-- This should fail at kernel level:
set_option debug.skipKernelTC false in
def testDef1 : Nat := 5

-- Same with skipKernelTC (should still work because it's correct)
set_option debug.skipKernelTC true in
def testDef2 : Nat := 10

-- Test 3: Definition with WRONG type claimed (would kernel catch this?)
-- Can't directly create this because elaborator will catch it

-- Test 4: What about a theorem with wrong proof?
set_option debug.skipKernelTC false in
theorem test1 : 1 = 1 := rfl  -- Should work

-- With skipKernelTC, can we provide wrong proof?
-- set_option debug.skipKernelTC true in
-- theorem test2 : 1 = 1 := (rfl : 2 = 2)  -- Elaborator will catch this

-- Test 5: The real question - does sorry bypass checking?
set_option debug.skipKernelTC false in
theorem withSorry1 : False := sorry  -- Kernel checks this adds sorry axiom

set_option debug.skipKernelTC true in
theorem withSorry2 : False := sorry  -- Does this skip adding to axiom list?

-- Test 6: Check if axioms are tracked
#print axioms withSorry1
#print axioms withSorry2

-- Test 7: Mutual recursion with bad termination
-- (This should fail at elaboration, not kernel)

-- Test 8: The key insight from AddDecl.lean:
-- skipKernelTC skips kernel type checking but not elaborator checking
-- So syntax errors, type errors, etc. are still caught
-- What it DOES skip: kernel validation that the declaration is well-typed
-- This matters for complex dependent types, universe levels, etc.

/-
CRITICAL REALIZATION:
From AddDecl.lean lines 19-22:
```lean
if debug.skipKernelTC.get opts then
  addDeclWithoutChecking env decl
else
  addDeclCore env (Core.getMaxHeartbeats opts).toUSize decl cancelTk?
```

So skipKernelTC skips `addDeclCore` which does kernel type checking.
But the elaborator has already run by this point!

The elaborator creates the Declaration, then it's passed to kernel.
skipKernelTC skips the kernel validation of that declaration.

This means:
- Elaborator already type-checked at elaboration level
- Kernel would normally re-check at kernel level (more rigorous)
- skipKernelTC skips that second, rigorous check

VULNERABILITY:
If there's a bug in the ELABORATOR (less trusted than kernel),
skipKernelTC would allow unsound declarations to slip through!
-/

-- Test 9: Can we find an elaborator bug to exploit?
-- Historical elaborator bugs in other proof assistants have existed

-- Test 10: Check what axioms are in environment
#eval do
  let env â† Lean.MonadEnv.getEnv
  let axioms := env.constants.fold (init := #[]) fun acc name info =>
    match info with
    | .axiomInfo _ => acc.push name
    | _ => acc
  IO.println s!"Axioms in environment: {axioms.size}"
  for ax in axioms.take 10 do
    IO.println s!"  {ax}"
  pure ()
