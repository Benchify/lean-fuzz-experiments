/-
EXPLOIT TEST 7: Using metaprogramming to enable skipKernelTC
Can Lean metaprogramming set options programmatically?

This tests if we can use Lean macros/tactics to sneakily enable skipKernelTC
-/

import Lean

open Lean Elab Command

-- Test 1: Can we read the current option value?
#eval show CoreM Bool from do
  let opts ← getOptions
  let val := debug.skipKernelTC.get opts
  IO.println s!"debug.skipKernelTC = {val}"
  return val

-- Test 2: Can we modify options in a macro or elaborator?
elab "sneakySetOption" : command => do
  -- Try to enable skipKernelTC from within elaborator
  let opts ← getOptions
  let newOpts := debug.skipKernelTC.set opts true
  -- Can we set the options?
  -- setOptions newOpts  -- This function might not exist or might not persist
  logInfo m!"Attempted to set skipKernelTC to true"
  logInfo m!"Current value: {debug.skipKernelTC.get opts}"
  logInfo m!"New value: {debug.skipKernelTC.get newOpts}"

-- Test the macro
sneakySetOption

-- Test 3: Does it work?
axiom afterMacro : False

-- Test 4: Can we use `withOptions` to scope the change?
elab "withSkipKernel" cmd:command : command => do
  -- Try to elaborate a command with skipKernelTC enabled
  let opts ← getOptions
  let newOpts := debug.skipKernelTC.set opts true
  withOptions (fun _ => newOpts) do
    elabCommand cmd

-- Try it
withSkipKernel (axiom metaSkip : False)

-- Test 5: Can we use attributes or annotations?
-- @[skipKernelTC] -- Would this work if we defined it?

-- Test 6: Building a declaration programmatically
-- If we construct a Declaration with Environment.addDeclWithoutChecking,
-- we bypass kernel checks entirely!

def buildEvilDecl : CoreM Unit := do
  let env ← getEnv
  -- Try to build a declaration programmatically
  -- This would require importing more Lean internals
  return ()

#eval buildEvilDecl

/-
ANALYSIS: Metaprogramming attack surface

From AddDecl.lean, addDecl reads opts from CoreM context:
  let env ← (← getEnv).addDeclAux (← getOptions) decl

So if we can control the Options in CoreM when addDecl runs,
we can enable skipKernelTC!

The question is: Can metaprogramming code modify the ambient Options?

Looking at MonadOptions:
- getOptions reads current options
- withOptions creates a local scope with modified options
- But does this affect addDecl calls within that scope?

ATTACK VECTOR:
If macros/tactics can use withOptions to wrap addDecl calls,
they might be able to sneak in declarations with skipKernelTC!
-/

-- Test 7: Can we override an axiom's type checking?
syntax "axiomWithoutCheck" ident ":" term : command

elab_rules : command
  | `(axiomWithoutCheck $name:ident : $type:term) => do
    logInfo m!"Attempting to add axiom {name} without checking"
    -- Here we'd need to:
    -- 1. Parse the type
    -- 2. Create an AxiomVal
    -- 3. Call addDeclWithoutChecking directly if possible
    -- But this requires accessing lower-level APIs
    return ()

-- Try it (will probably fail, but documents the attack idea)
-- axiomWithoutCheck evilMeta : False

/-
KEY INSIGHT:
If metaprogramming code can call Environment.addDeclWithoutChecking directly
(which is opaque but might be accessible), it can bypass kernel entirely!

From Environment.lean:
  opaque addDeclWithoutChecking (env : Environment) (decl : @& Declaration) : Except Exception Environment

This is an OPAQUE function but it exists in the API!
If untrusted metaprogramming code can call it, CRITICAL vulnerability!
-/

#check Lean.Environment.addDecl  -- The safe function
-- #check Lean.Environment.addDeclWithoutChecking  -- Can we access this?

-- Test 8: Can untrusted code import and use it?
-- This depends on whether addDeclWithoutChecking is truly opaque
-- or if there's a way to access it from user code
