/-
Advanced Test 5: Definitional Equality Exploits
Attempting to confuse definitional equality checking to derive False

Definitional equality in Lean is the equivalence generated by:
- Beta reduction: (λ x => t) s ≡ t[s/x]
- Eta conversion: (λ x => f x) ≡ f (if x not free in f)
- Iota reduction: Pattern matching reduction
- Delta reduction: Unfolding definitions

Potential exploits:
- Incorrect reduction order
- Non-terminating reduction
- Eta conversion bugs with dependent types
- Proof irrelevance confusion
-/

-- Test 1: Beta reduction edge cases
def betaTest1 := (fun x : Nat => x + 1) 0
def betaTest2 := 1

-- These should be definitionally equal
example : betaTest1 = betaTest2 := rfl

-- Test 2: Nested beta with dependent types
def depBeta (α : Type) := (fun (β : Type) (x : β) => x) α

-- Test 3: Eta conversion with proof irrelevance
def etaTest1 (P : Prop) (h : P) := h
def etaTest2 (P : Prop) := fun (h : P) => h

-- Should be equal
example (P : Prop) : etaTest1 P = etaTest2 P := rfl

-- Test 4: Iota reduction - pattern matching should reduce
def iotaTest1 : Nat := match (5 : Nat) with | n => n + 1
def iotaTest2 : Nat := 6

example : iotaTest1 = iotaTest2 := rfl

-- Test 5: Delta reduction with circular definitions?
-- Can we create definitions that confuse unfolding?
def circDef1 := circDef2 + 1
def circDef2 := 0

-- Test 6: Reduction with partial functions
partial def partialLoop : Nat → Nat
  | 0 => 0
  | n + 1 => partialLoop (n + 1)  -- Non-terminating

-- Can definitional equality checker get stuck?
-- def stuckTest := partialLoop 1  -- Might not terminate during type checking

-- Test 7: Proof irrelevance edge case
-- Two proofs of same Prop should be definitionally equal
theorem proof1 : 1 = 1 := rfl
theorem proof2 : 1 = 1 := Eq.refl 1

example : proof1 = proof2 := rfl  -- Should work (proof irrelevance)

-- Test 8: Subsingleton elimination
-- Can we confuse this with Type vs Prop?
def subsingletonTest (h1 h2 : 1 = 1) : h1 = h2 := rfl

-- Test 9: Definitional equality with type classes
class MyClass (α : Type) where
  myVal : α

instance : MyClass Nat where
  myVal := 42

instance : MyClass Nat where  -- Overlapping instance!
  myVal := 43

-- Test 10: Reduction with match on equality
def matchEqTest {α : Type} (x y : α) (h : x = y) : α :=
  match h with
  | rfl => x  -- After matching, y should be definitionally equal to x

-- Test 11: Complex nested reduction
def nested1 := (fun x => (fun y => x + y) 2) 3
def nested2 := 5

example : nested1 = nested2 := rfl

-- Test 12: Reduction with mutual recursion
mutual
  def even : Nat → Bool
    | 0 => true
    | n + 1 => odd n

  def odd : Nat → Bool
    | 0 => false
    | n + 1 => even n
end

-- Should reduce properly
example : even 4 = true := rfl
example : odd 3 = true := rfl

-- Test 13: Opaque definitions
-- Can we bypass opacity to confuse equality?
def opaqueTest : Nat := 42

-- Normally can't see through opaque
-- But are there ways to bypass this?

-- Test 14: Prop vs Type definitional equality
-- Prop is definitionally different from Type
-- Can we confuse them?
-- def propTypeConfusion : Prop = Type := rfl  -- Should fail

-- Test 15: Reduction with sorry
def sorryTest := sorry

-- Using sorry in definitional equality
-- def useSorry : sorryTest = (42 : Nat) := rfl  -- Type error expected

-- Test 16: Non-normalizing terms in definitions
-- Do these cause kernel to loop?
-- def loopDef : Nat := loopDef + 1  -- Should require 'partial'

-- Test 17: Eta for dependent functions
def depEta1 : (n : Nat) → Fin (n + 1) := fun n => ⟨0, Nat.zero_lt_succ n⟩
def depEta2 (n : Nat) : Fin (n + 1) := ⟨0, Nat.zero_lt_succ n⟩

-- Are these definitionally equal?
-- example : depEta1 = depEta2 := rfl  -- May fail (different forms)

-- Test 18: Reduction with type casts
def castTest (h : Nat = Nat) : Nat := cast h 42

-- Test 19: Definitional equality of applications
def app1 := Nat.add 1
def app2 := (· + 1)

-- Partial application should reduce
-- example (n : Nat) : app1 n = app2 n := rfl

-- Test 20: Match on impossible cases
def impossibleMatch (n : Nat) (h : n < 0) : False :=
  match n, h with
  | _, h' => Nat.not_lt_zero n h'

#check betaTest1
#check proof1
#check even
#check impossibleMatch
